setwd("Documents/CMEECourseWork/Week3/Code")
#############################################################################
##################### Autocorrelation in weather ############################
#############################################################################
# imports
library(dplyr)
# load weather data
load("../Data/KeyWestAnnualMeanTemperature.Rdata")
# plot tmperatures over time on line graph
pdf("../Results/KWAMT.pdf", 6, 4)
plot(ats$Year,
ats$Temp,
xlab = "Temp (Degrees Centigrade)",
ylab = "Year",
type = "l")
# create two lists of tmperatures, one with the first row deleted and then
# realigned with the second list so temps between suuccesive years can be
# easily compared
Temp_t0 <- c(ats[2:100,2])
Temp_t1 <- c(ats[1:99,2])
# calculate the correlation between successive years
CorCoeff <- cor(Temp_t0, Temp_t1)
print(CorCoeff)
# create matrix of 10000 random permututions of temperature column
Temps1 <- replicate(10000,  sample(ats$Temp,replace = F))
# for each permutation, realign as before and then calculate correlation
RdmCors <- vector("numeric", 10000)
for (i in 1 : 10000) {
RdmTemps <- cor( Temps1[2:100,i], Temps1[1:99,i])
RdmCors[i] <- RdmTemps
}
# calculate the fraction of correlation coefficients more significant than
# that of successive years (CorCoeff)
sum(RdmCors > CorCoeff) + sum (RdmCors < -CorCoeff)
#############################################################################
##################### Autocorrelation in weather ############################
#############################################################################
# imports
library(dplyr)
# load weather data
load("../Data/KeyWestAnnualMeanTemperature.Rdata")
# plot tmperatures over time on line graph
pdf("../Results/KWAMT.pdf")
plot(ats$Year,
ats$Temp,
xlab = "Temp (Degrees Centigrade)",
ylab = "Year",
type = "l")
# create two lists of tmperatures, one with the first row deleted and then
# realigned with the second list so temps between suuccesive years can be
# easily compared
Temp_t0 <- c(ats[2:100,2])
Temp_t1 <- c(ats[1:99,2])
# calculate the correlation between successive years
CorCoeff <- cor(Temp_t0, Temp_t1)
print(CorCoeff)
# create matrix of 10000 random permututions of temperature column
Temps1 <- replicate(10000,  sample(ats$Temp,replace = F))
# for each permutation, realign as before and then calculate correlation
RdmCors <- vector("numeric", 10000)
for (i in 1 : 10000) {
RdmTemps <- cor( Temps1[2:100,i], Temps1[1:99,i])
RdmCors[i] <- RdmTemps
}
# calculate the fraction of correlation coefficients more significant than
# that of successive years (CorCoeff)
sum(RdmCors > CorCoeff) + sum (RdmCors < -CorCoeff)
source('~/Documents/CMEECourseWork/Week3/Code/TAutoCorr.R')
################################################################
################## Wrangling the Pound Hill Dataset ############
################################################################
############# Load the dataset ###############
# header = false because the raw data don't have real headers
MyData <- as.matrix(read.csv("../Data/PoundHillData.csv",header = F))
# header = true because we do have metadata headers
MyMetaData <- read.csv("../Data/PoundHillMetaData.csv",
header = T,
sep=";",
stringsAsFactors = F)
############# Inspect the dataset ###############
head(MyData)
dim(MyData)
str(MyData)
#fix(MyData) #you can also do this
#fix(MyMetaData)
############# Transpose ###############
# To get those species into columns and treatments into rows
MyData <- t(MyData)
head(MyData)
dim(MyData)
############# Replace species absences with zeros ###############
MyData[MyData == ""] = 0
############# Convert raw matrix to data frame ###############
TempData <- as.data.frame(MyData[-1,],stringsAsFactors = F) #stringsAsFactors = F is important!
colnames(TempData) <- MyData[1,] # assign column names from original data
############# Convert from wide to long format  ###############
require(reshape2) # load the reshape2 package
?melt #check out the melt function
MyWrangledData <- melt(TempData,
id=c("Cultivation", "Block", "Plot", "Quadrat"),
variable.name = "Species",
value.name = "Count")
MyWrangledData[, "Cultivation"] <- as.factor(MyWrangledData[, "Cultivation"])
MyWrangledData[, "Block"] <- as.factor(MyWrangledData[, "Block"])
MyWrangledData[, "Plot"] <- as.factor(MyWrangledData[, "Plot"])
MyWrangledData[, "Quadrat"] <- as.factor(MyWrangledData[, "Quadrat"])
MyWrangledData[, "Count"] <- as.integer(MyWrangledData[, "Count"])
str(MyWrangledData)
head(MyWrangledData)
dim(MyWrangledData)
################################################################
################## Wrangling the Pound Hill Dataset ############
################################################################
require(dplyr)
require(tidyr)
############# Load the dataset ###############
# header = false because the raw data don't have real headers
MyData <- as.matrix(read.csv("../Data/PoundHillData.csv",header = F))
# header = true because we do have metadata headers
MyMetaData <- read.csv("../Data/PoundHillMetaData.csv",
header = T,
sep=";",
stringsAsFactors = F)
############# Inspect the dataset ###############
head(MyData)
dim(MyData)
glimpse(MyData) # like str() but tidier
#fix(MyData) #you can also do this
#fix(MyMetaData)
############# Transpose ###############
# To get those species into columns and treatments into rows
MyData <- t(MyData)
head(MyData)
dim(MyData)
############# Replace species absences with zeros ###############
MyData[MyData == ""] = 0
############# Convert raw matrix to data frame ###############
TempData <- as.data.frame(MyData[-1,],stringsAsFactors = F) #stringsAsFactors = F is important!
colnames(TempData) <- MyData[1,] # assign column names from original data
############# Convert from wide to long format  ###############
MyWrangledData <- TempData %>%
gather(Species, Count, -Cultivation, -Block, -Plot, -Quadrat)
MyWrangledData[, "Cultivation"] <- as.factor(MyWrangledData[, "Cultivation"])
MyWrangledData[, "Block"] <- as.factor(MyWrangledData[, "Block"])
MyWrangledData[, "Plot"] <- as.factor(MyWrangledData[, "Plot"])
MyWrangledData[, "Quadrat"] <- as.factor(MyWrangledData[, "Quadrat"])
MyWrangledData[, "Count"] <- as.integer(MyWrangledData[, "Count"])
glimpse(MyWrangledData) # like str() but tidier
head(MyWrangledData)
dim(MyWrangledData)
################### Calculating a linear model for predator and prey masses #####################
############################ by feeding type and predator lifestage #############################
# Plots graphs from predator and prey size data, including linear regressions,
# differentiated by predator lifestage, facected by type of feeding interaction and saves to pdf.
# Calculates regression results corresponding to the lines fitted in the figure and saves as
# csv demlimited table.
# clear workspace
rm(list=ls())
# imports
library(ggplot2)
library(dplyr)
# load the data
MyDF <- read.csv("../Data/EcolArchives-E089-51-D1.csv")
dim(MyDF) # check the size of the data frame you loaded
pdf("../Results/PP_Regress.pdf", # open blank pdf page using a relative path
8.3, 11.7)  # page dimensions in inches
# plot the predator and prey mass by feeding type and predator lifestage using the linear model method
qplot(Prey.mass, Predator.mass, data = MyDF, log="xy",
xlab = "Prey mass in grams",
ylab = "Predator mass in grams",
colour = Predator.lifestage, shape = I(3)) +
geom_smooth(method = "lm",fullrange = TRUE) + # plot linear regressions
facet_grid(Type.of.feeding.interaction~.) + # all plots on the same grid
theme_bw() %+replace%
theme(legend.position = "bottom",
panel.border = element_rect(colour = "grey", fill = NA)) +
guides(colour = guide_legend(nrow = 1)) + # put legend on one line
theme(legend.title = element_text(size = 9, face="bold"))
graphics.off() # close all open devices/windows
# calculate the regression results corresponding to the lines fitted in the figure
LM <- MyDF %>%
# first remove subset that contains only 2 examples, both with same species of prey and predator,
# because f-statistic can't be calculated on this (and no linear regression line can be drawn)
filter(Record.number != "30914" & Record.number != "30929") %>%
# subset only the data needed and group by feeeding type and predator lifestage
select(Record.number, Predator.mass, Prey.mass, Predator.lifestage, Type.of.feeding.interaction) %>%
group_by(Type.of.feeding.interaction, Predator.lifestage) %>%
# do linear model calculations and store specific values as columns to dataframe
do(mod=lm(Predator.mass ~ Prey.mass, data = .)) %>%
mutate(Regression.slope = summary(mod)$coeff[2],
Regression.intercept = summary(mod)$coeff[1],
R.squared = summary(mod)$adj.r.squared,
Fstatistic = summary(mod)$fstatistic[1],
P.value = summary(mod)$coeff[8]) %>%
select(-mod) # remove column created by mod=lm command
# save the regression results to a csv delimited table
write.csv(LM, "../Results/PP_Regress_Results.csv")
##################### First plot with annotations #######################
# loads data from a .txt file and plots it as three line ranges
# (using ggplot2) with annotations for particular values.
# clear workspace
rm(list=ls())
# imports
library(ggplot2)
# read data
a <- read.table("../Data/Results.txt", header = TRUE)
# view data
head(a)
a$ymin <- rep(0, dim(a)[1]) # append a column of zeroes
# print the first linerange
p <- ggplot(a)
p <- p + geom_linerange(data = a, aes(
x = x,
ymin = ymin,
ymax = y1,
size = (0.5),
colour = "#E69F00",
alpha = 1/2),
show.legend = TRUE)
# print the second linerange
p <- p + geom_linerange(data = a, aes(
x = x,
ymin = ymin,
ymax = y2,
size = (0.5),
colour = "#56B4E9",
alpha = 1/2),
show.legend = FALSE)
# print the third linerange
p <- p + geom_linerange(data = a, aes(
x =x,
ymin = ymin,
ymax = y3,
size = (0.5),
colour = "#D55E00",
alpha = 1/2),
show.legend = FALSE)
# annonate the plot with labels
p <- p + geom_text(data = a, aes(x =x, y = -500, label = Label))
# now set the axis labels, remove the legend, and preapre for bw printing
p <- p + scale_x_continuous("My x axis",
breaks = seq(3, 5, by = 0.05)) +
scale_y_continuous("My y axis") +
theme_bw() +
theme(legend.position = "none")
pdf("../Results/MyBars.pdf")
p #+ ggtitle("My first annotated plot")
dev.off()
######## Mathematical notation on an axis and in plot area ##############
# performs a linear regression on some sample data, plots the data with
# the regression line and then annotates the plot with a mathematical equation.
# clear workspace
rm(list=ls())
# imports
library(ggplot2)
# create some linear regression data
x <- seq(0, 100, by = 0.1)
y <- -4. + 0.25*x +
rnorm(length(x), mean = 0., sd = 2.5)
# put data in a dataframe
my_data <- data.frame(x = x, y = y)
# perform a linear regression
my_lm <- summary(lm(y ~ x, data = my_data))
# plot the data
p <- ggplot(my_data, aes(x = x,
y = y,
colour = abs(my_lm$residual))) +
geom_point() +
scale_colour_gradient(low = "black", high = "red") +
theme(legend.position = "none") +
scale_x_continuous(expression(alpha^2 * pi / beta * sqrt(Theta)))
# add regresssion line
p <- p + geom_abline(intercept = my_lm$coefficients[1][1],
slope = my_lm$coefficients[2][1],
colour = "red")
# put the mathematical equation on the plot
p <- p + geom_text(aes(x = 60,
y = 0,
label = "sqrt(alpha) * 2 * pi"),
parse = TRUE,
size = 6,
colour = "blue")
# save result into a pdf
pdf("../Results/MyLinReg.pdf")
p + ggtitle("Plot with mathematical display")
dev.off()
##### Plots a map showing spaital spread of species from dataset #######
########################################################################
# plots an empty world map using the maps package and adds data points
# from a dataset containing species and corresponding longitudes and
# latitudes
#imports
library(maps)
# load the data
load("../Data/GPDDFiltered.RData")
# plot the map using the maps package
map(database = "world", fill=TRUE, col="darkolivegreen3",
bg = "cadetblue2", ylim = c(-60,90), border = "grey66")
# plot the data points onto the map
points(x = gpdd$long, y = gpdd$lat, col = "black", pch = 1, cex = 0.35)
# Expected biases:
# Spatial bias!
# 1) Data points are from temperate regions so no weighting
# from tripoical species (however analysis may be specifically
# focussed on species from temperate regions)
# 2) Most data is from UK or the west coast of USA, not representative
# of actual biodiversity of species across temperate regions
############################# Plotting lattice graphs ##################################
######################## and calculating means and medians ##############################
# Using a dataset containing predator-prey body size information, plots 3 lattice graphs
# showing predator and prey masses and the ration between them by types of food interaction.
# Also calculates mean and median for the above subsets.
# imports
library(lattice)
library(dplyr)
# close all currently open devices
dev.off()
# load the data
PPDataFrame <- read.csv("../Data/EcolArchives-E089-51-D1.csv")
# plot a lattice plot of predator mass by type feeding interation and save as pdf
pdf("../Results/Pred_Lattice.pdf", # open blank pdf page using a relative path
11.7, 8.3) # these numbers are page dimensions in inches
densityplot(~log(Predator.mass) | Type.of.feeding.interaction, data = PPDataFrame)
graphics.off()
# plot a lattice plot of prey mass by type feeding interation and save as pdf
pdf("../Results/Prey_Lattice.pdf",
11.7, 8.3)
densityplot(~log(Prey.mass) | Type.of.feeding.interaction, data = PPDataFrame)
graphics.off()
# plot a lattice plot of the size ratio of prey mass over predator mass by type feeding interation and save as pdf
pdf("../Results/SizeRatio_Lattice.pdf",
11.7, 8.3)
densityplot(~log(Prey.mass/Predator.mass) | Type.of.feeding.interaction, data = PPDataFrame)
graphics.off()
# save to csv mean and median of predator mass, prey mass, and size ratio by type of feeding interaction
# using ddplyr and grouping by type of feeding interaction
Averages <- PPDataFrame %>%
group_by(Type.of.feeding.interaction) %>%
summarise(mean(log(Predator.mass)),
median(log(Predator.mass)),
mean(log(Prey.mass)),
median(log(Prey.mass)),
mean(log(Prey.mass/Predator.mass)),
median(log(Prey.mass/Predator.mass)))
names(Averages) <- c("Feeding.Type",
"Mean:log.of.predator.mass",
"Median:log.of.predator.mass",
"Mean:log.of.prey.mass",
"Median:log.of.prey.mass",
"Mean:log.of.prey.mass/predator.mass",
"Median:log.of.prey.mass/predator.mass")
write.csv(Averages, "../Results/PP_Results.csv")
############################# Plotting lattice graphs ##################################
######################## and calculating means and medians ##############################
# Using a dataset containing predator-prey body size information to plot 3 lattice graphs
# showing predator and prey masses and the ratio between them by types of food interaction.
# Also calculates mean and median for the above subsets and saves to csv.
# clear workspace
rm(list=ls())
# imports
library(lattice)
library(dplyr)
# close all currently open devices
dev.off()
# load the data
PPDataFrame <- read.csv("../Data/EcolArchives-E089-51-D1.csv")
# plot a lattice plot of predator mass by type feeding interation and save as pdf
pdf("../Results/Pred_Lattice.pdf", # open blank pdf page using a relative path
11.7, 8.3) # these numbers are page dimensions in inches
densityplot(~log(Predator.mass) | Type.of.feeding.interaction, data = PPDataFrame)
graphics.off()
# plot a lattice plot of prey mass by type feeding interation and save as pdf
pdf("../Results/Prey_Lattice.pdf",
11.7, 8.3)
densityplot(~log(Prey.mass) | Type.of.feeding.interaction, data = PPDataFrame)
graphics.off()
# plot a lattice plot of the size ratio of prey mass over predator mass by type feeding interation and save as pdf
pdf("../Results/SizeRatio_Lattice.pdf",
11.7, 8.3)
densityplot(~log(Prey.mass/Predator.mass) | Type.of.feeding.interaction, data = PPDataFrame)
graphics.off()
# save to csv mean and median of predator mass, prey mass, and size ratio by type of feeding interaction
# using ddplyr and grouping by type of feeding interaction
Averages <- PPDataFrame %>%
group_by(Type.of.feeding.interaction) %>%
summarise(mean(log(Predator.mass)),
median(log(Predator.mass)),
mean(log(Prey.mass)),
median(log(Prey.mass)),
mean(log(Prey.mass/Predator.mass)),
median(log(Prey.mass/Predator.mass)))
names(Averages) <- c("Feeding.Type",
"Mean:log.of.predator.mass",
"Median:log.of.predator.mass",
"Mean:log.of.prey.mass",
"Median:log.of.prey.mass",
"Mean:log.of.prey.mass/predator.mass",
"Median:log.of.prey.mass/predator.mass")
write.csv(Averages, "../Results/PP_Results.csv")
