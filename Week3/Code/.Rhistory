process_cluster_results <- function(){
octaves_500 <- list()
octaves_1000 <- list()
octaves_2500 <- list()
octaves_5000 <- list()
counter <- 0
for (i in 1:3){
load(paste0("../../Week9/Results/Results",i,".rda"))
octaves_tot <- list()
for (j in length(ocatves_list)){
octaves_tot <- sum_vect(octaves_tot, octaves_list[[j]])
counter <- counter + 1
}
if (size == 500){
octaves_500 <- sum_vect(octaves_500, octaves_tot)
}
if (size == 1000){
octaves_1000 <- sum_vect(octaves_1000, octaves_tot)
}
if (size == 2500){
octaves_2500 <- sum_vect(octaves_2500, octaves_tot)
}
if (size == 5000){
octaves_5000 <- sum_vect(octaves_5000, octaves_tot)
}
}
# clear any existing graphs and plot your graph within the R window
graphics.off()
par(mfrow = c(2, 2))
barplot(octaves_500)
barplot(octaves_1000)
barplot(octaves_2500)
barplot(octaves_5000)
combined_results <- list(octaves_500, octaves_1000, octaves_2500, octaves_5000) #create your list output here to return
return(combined_results)
}
# CMEE 2019 HPC excercises R code HPC run code proforma
rm(list=ls()) # good practice
source("leg19_HPC_2019_main.R")
# it should take a faction of a second to source your file
# if it takes longer you're using the main file to do actual simulations
# it should be used only for defining functions that will be useful for your cluster run and which will be marked automatically
# do what you like here to test your functions (this won't be marked)
# for example
#species_richness(c(1,4,4,5,1,6,1))
# should return 4 when you've written the function correctly for question 1
# you may also like to use this file for playing around and debugging
# but please make sure it's all tidied up by the time it's made its way into the main.R file or other files.
process_cluster_results()
source("leg19_HPC_2019_main.R")
setwd("../../Week9/Code/")
source("leg19_HPC_2019_main.R")
process_cluster_results()
source("leg19_HPC_2019_main.R")
process_cluster_results()
source("leg19_HPC_2019_main.R")
process_cluster_results()
octaves_tot <- list()
length(octaves_list)
files <- list.files(path = "../Results/", pattern = "*.rda")
for (i in files){
load(paste0("..//Results/",i))
}
View(octaves_list)
for (j in length(octaves_list)){
octaves_tot <- sum_vect(octaves_tot, octaves_list[[j]])
counter <- counter + 1
}
source("leg19_HPC_2019_main.R")
process_cluster_results()
process_cluster_results()
process_cluster_results()
source("leg19_HPC_2019_main.R")
process_cluster_results()
source("leg19_HPC_2019_main.R")
process_cluster_results()
source("leg19_HPC_2019_main.R")
process_cluster_results()
source("leg19_HPC_2019_main.R")
process_cluster_results()
source("leg19_HPC_2019_main.R")
process_cluster_results()
source('~/Documents/CMEECourseWork/Project/Proposal/WorkingDocuments/Proposal_Gantt.R')
############## Gantt Chart for MRes Proposal ###############
# clear workspace
rm(list=ls())
# load packages
library(ggplot2)
require(dplyr)
library(forcats)
# create data frame of tasks and times
data <-data.frame(task = c('Probe analysis in lab',
'Literature review',
'Statistics and Modelling',
'Data Analysis',
'Final Submission Deadline',
'Data Exploration',
'Results and Final Write-Up',
'Introduction Write-Up',
'Methods Write-Up',
'HPC pipeline'),
start.date = as.Date(c("2020-03-02",
"2019-12-16",
"2020-02-03",
"2020-03-02",
"2020-08-26",
"2019-12-30",
"2020-06-22",
"2019-12-30",
"2020-03-16",
"2019-12-16")),
end.date = as.Date(c("2020-03-29",
"2020-07-12",
"2020-03-02",
"2020-06-29",
"2020-08-27",
"2020-02-03",
"2020-07-30",
"2020-03-02",
"2020-05-15",
"2019-12-20")),
type = c('Lab',
'Reading',
'Taught module',
'Computational',
'Deadline',
'Computational',
'Writing',
'Writing',
'Writing',
'Computational'))
# plot Gantt chart
brks <- c(seq(from = as.Date("2019-12-09"), to = as.Date("2020-09-06"),
by = "month"))
pdf("GanttChart.pdf", 9, 3.2)
data %>% mutate(task = fct_reorder(task, desc(start.date))) %>% # order tasks by start date in decending order
ggplot(aes(x = start.date,
xend = end.date,
y = task,
yend = task,
group = start.date,
colour = type)) +
geom_segment(size = 6) +
theme_bw() +
theme(legend.title = element_blank(),
legend.position = "bottom",
legend.text=element_text(size=11),
axis.text.x = element_text(size = 11),
axis.text.y = element_text(size = 11)) +
scale_x_date(breaks = brks,
date_labels = "%b",
position = "top") +
labs(x = NULL,
y = NULL)
dev.off()
source('~/Documents/CMEECourseWork/Project/Proposal/WorkingDocuments/Proposal_Gantt.R')
setwd("../../Project/Proposal/WorkingDocuments/")
source('~/Documents/CMEECourseWork/Project/Proposal/WorkingDocuments/Proposal_Gantt.R')
source('~/Documents/CMEECourseWork/Project/Proposal/WorkingDocuments/Proposal_Gantt.R')
############## Gantt Chart for MRes Proposal ###############
# clear workspace
rm(list=ls())
# load packages
library(ggplot2)
require(dplyr)
library(forcats)
# create data frame of tasks and times
data <-data.frame(task = c('Probe analysis in lab',
'Literature review',
'Statistics and Modelling',
'Data Analysis',
'Final Submission Deadline',
'Data Exploration',
'Results and Final Write-Up',
'Introduction Write-Up',
'Methods Write-Up',
'HPC pipeline'),
start.date = as.Date(c("2020-03-02",
"2019-12-16",
"2020-02-03",
"2020-03-02",
"2020-08-26",
"2019-12-30",
"2020-06-22",
"2019-12-30",
"2020-03-16",
"2019-12-16")),
end.date = as.Date(c("2020-03-29",
"2020-07-12",
"2020-03-02",
"2020-06-29",
"2020-08-27",
"2020-02-03",
"2020-07-30",
"2020-03-02",
"2020-05-15",
"2019-12-20")),
type = c('Lab',
'Reading',
'Taught module',
'Computational',
'Deadline',
'Computational',
'Writing',
'Writing',
'Writing',
'Computational'))
# plot Gantt chart
brks <- c(seq(from = as.Date("2019-12-09"), to = as.Date("2020-09-06"),
by = "month"))
pdf("GanttChart.pdf", 9, 3)
data %>% mutate(task = fct_reorder(task, desc(start.date))) %>% # order tasks by start date in decending order
ggplot(aes(x = start.date,
xend = end.date,
y = task,
yend = task,
group = start.date,
colour = type)) +
geom_segment(size = 6) +
theme_bw() +
theme(legend.title = element_blank(),
legend.position = "bottom",
legend.text=element_text(size=11),
axis.text.x = element_text(size = 11),
axis.text.y = element_text(size = 11)) +
scale_x_date(breaks = brks,
date_labels = "%b",
position = "top") +
labs(x = NULL,
y = NULL)
dev.off()
############### Two methods of creating a matrix ################
# Two methods of creating a matrix, one without using preallocation (function, f)
# and one using preallocaiton (function, g). The times taken for each function
# to run are printed to allow comparison.
# Author: Lucy Goodyear (lucy.goodyear19@imperial.ac.uk)
# Version: 0.0.1
# clear workspace
rm(list=ls())
a <- NA
f <- function(a) {
for (i in 1:10000) {
a <- c(a, i)
# in-function print commands have been commented out
# to increase speed
#print(a)
#print(object.size(a))
}
}
a <- rep(NA, 10)
g <- function(a) {
for (i in 1:10000) {
a[i] <- i
# in-function print commands have been commented out
# to increase speed
#print(a)
#print(object.size(a))
}
}
# compare difference in computing times:
# time taken for first function
print("Time taken without preallocation:")
print(system.time(f(a)))
# time taken for second function
print("Time taken with preallocation:")
print(system.time(g(a)))
a <- NA
class(a)
############## Practice using next command ####################
# Uses next to skip to the next iteration of a loop.
# The loop checks which numbers between 1 and 10 are odd by
# using the modulo operation and then all odd numbers are printed.
# Author: Lucy Goodyear (lucy.goodyear19@imperial.ac.uk)
# Version: 0.0.1
# clear workspace
rm(list=ls())
# a for loop that prints only odd numbers
for (i in 1:10) {
if ((i %% 2) == 0)
next # pass to next iteration of loop
print(i)
}
################## boilerplate R script ######################
# Contains an example function and test print outs.
# Author: Lucy Goodyear (lucy.goodyear19@imperial.ac.uk)
# Version: 0.0.1
# clear workspace
rm(list=ls())
MyFunction <- function(Arg1, Arg2){
# statements involving Arg1, Arg2
print(paste("Argument", as.character(Arg1), "is a", class(Arg1))) # print Arg1's type
print(paste("Argument", as.character(Arg2), "is a", class(Arg2))) # print Arg2's type
return (c(Arg1, Arg2)) # this is optional but very useful
}
MyFunction(1, 2) # test the function
MyFunction("Riki", "Tiki") # a different test
######### run a simulation that involves sampling from a population #########
# Contains 6 functions to test the speed of 5 different methods of calculating
# means. The first function, myexperiment, samples the data and calculates
# the mean of that sample, the other functions run "num" iterations over
# myexperiment to generate the means of "num" samples. The functions are then
# run on identical parameters and timed, with the time taken for each being
# printed to screen.
# Author: Lucy Goodyear (lucy.goodyear19@imperial.ac.uk)
# Version: 0.0.1
# clear workspace
rm(list=ls())
# a function to take a sample of size n from a population "popn" and return its mean
myexperiment <- function(popn, n){
pop_sample <- sample(popn, n, replace = FALSE)
return(mean(pop_sample))
}
# calculate means using a loop without preallocation
loopy_sample1 <- function(popn, n, num) {
result1 <- vector() # initialise empty vector of size 1
for (i in 1:num){
result1 <- c(result1, myexperiment(popn, n))
}
return(result1)
}
# to run "num" iterations of the experiment using a for loop on a vector with preallocation
loopy_sample2 <- function(popn, n, num) {
result2 <- vector(,num) # preallocate expected size
for (i in 1:num) {
result2[i] <- myexperiment(popn, n)
}
return(result2)
}
# to run "num" iterations of the experiment using a for loop on a list with preallocation
loopy_sample3 <- function(popn, n, num) {
result3 <- vector("list", num) # preallocate expected size
for (i in 1:num) {
result3[[i]] <- myexperiment(popn, n)
}
return(result3)
}
# to run "num" iterations of the experiment using vectorisation with lapply
lapply_sample <- function(popn, n, num) {
result4 <- lapply(1:num, function(i) myexperiment(popn, n))
return(result4)
}
# to run "num" iterations of the experiment using vectorisation with sapply
sapply_sample <- function(popn, n, num) {
result5 <- sapply(1:num, function(i) myexperiment(popn, n))
return(result5)
}
# generate the population
popn <- rnorm(1000)
hist(popn)
n <- 20 # sample size for each experiment
num <- 1000 # number of times to rerun the experiment
# time each function and print time to screen
print("The loopy, non-preallocation approach takes:")
print(system.time(loopy_sample1(popn, n, num)))
print("The loopy, but with preallocation approach takes:")
print(system.time(loopy_sample2(popn, n, num)))
print("The loopy, non-preallocation approach takes:")
print(system.time(loopy_sample3(popn, n, num)))
print("The vectorized lapply approach takes:")
print(system.time(sapply_sample(popn, n, num)))
print("The vectorized sapply approach takes:")
print(system.time(sapply_sample(popn, n, num)))
######## Practice script looking at using apply on some of R's inbuilt functions ########
# Uses the apply function to calculate the means and variance of each row and the means
# of each column of a random matrix.
# Author: Lucy Goodyear (lucy.goodyear19@imperial.ac.uk)
# Version: 0.0.1
# clear workspace
rm(list=ls())
# build a random matrix
M <- matrix(rnorm(100), 10, 10)
# take the mean of each row
RowMeans <- apply(M, 1, mean)
print(RowMeans)
# now take the variance
RowVars <- apply(M, 1 ,var)
print(RowVars)
# take means by column
ColMeans <- apply(M, 2, mean)
print(ColMeans)
######### Practice script looking at using apply on my own function #########
# Contains a function that takes one parameter, which, if the sum
# is greater than 0, is returned multipled by 100. The apply function
# is used to apply this function to a matrix by row.
# Author: Lucy Goodyear (lucy.goodyear19@imperial.ac.uk)
# Version: 0.0.1
# clear workspace
rm(list=ls())
# create a function
SomeOperation <- function(v) {
if (sum(v) > 0){
return(v * 100)
}
return(v)
}
# create a test argument and use apply to run your function on
# all elements at once
M <- matrix(rnorm(100), 10, 10)
print (apply(M, 1, SomeOperation))
################## Calculate tree heights #####################
# Contains a function that calculates heights of trees, which
# is called on a sample pair of parameters and then on a
# loaded data set of trees, the results of which are saved into a csv.
# The function calculates heights of trees given the distance
# of each tree from its base and angle to its top, using the
# trigonometric formula
# height = distance * tan(radians)
# Arguments:
# degrees: The angle of elevation of tree
# distance: The distance from base of tree (e.g. metres)
# Output:
# the heights of the trees, same units as "distance"
# Author: Lucy Goodyear (lucy.goodyear19@imperial.ac.uk)
# Version: 0.0.1
# clear workspace
rm(list=ls())
# loads data from a csv
Tree_data <- read.csv("../Data/trees.csv")
TreeHeight <- function(degrees, distance){
radians <- degrees * pi / 180
height <- distance * tan(radians)
# commented out print function below to improve speed with large datasets
#print(paste("Tree height is", height))
return(height)
}
TreeHeight(37, 40) # sample values
# add column to Tree_data to include tree heights, calculated by the TreeHeight function
Tree_data$Tree.Height.m <- TreeHeight(Tree_data$Angle.degrees, Tree_data$Distance.m)
# write data to a csv
write.csv(Tree_data, "../Results/TreeHts.csv")
setwd("../../../Week3/Code/")
################## Calculate tree heights #####################
# Contains a function that calculates heights of trees, which
# is called on a sample pair of parameters and then on a
# loaded data set of trees, the results of which are saved into a csv.
# The function calculates heights of trees given the distance
# of each tree from its base and angle to its top, using the
# trigonometric formula
# height = distance * tan(radians)
# Arguments:
# degrees: The angle of elevation of tree
# distance: The distance from base of tree (e.g. metres)
# Output:
# the heights of the trees, same units as "distance"
# Author: Lucy Goodyear (lucy.goodyear19@imperial.ac.uk)
# Version: 0.0.1
# clear workspace
rm(list=ls())
# loads data from a csv
Tree_data <- read.csv("../Data/trees.csv")
TreeHeight <- function(degrees, distance){
radians <- degrees * pi / 180
height <- distance * tan(radians)
# commented out print function below to improve speed with large datasets
#print(paste("Tree height is", height))
return(height)
}
TreeHeight(37, 40) # sample values
# add column to Tree_data to include tree heights, calculated by the TreeHeight function
Tree_data$Tree.Height.m <- TreeHeight(Tree_data$Angle.degrees, Tree_data$Distance.m)
# write data to a csv
write.csv(Tree_data, "../Results/TreeHts.csv")
############## Practice using next command ####################
# Uses next to skip to the next iteration of a loop.
# The loop checks which numbers between 1 and 10 are odd by
# using the modulo operation and then all odd numbers are printed.
# Author: Lucy Goodyear (lucy.goodyear19@imperial.ac.uk)
# Version: 0.0.1
# clear workspace
rm(list=ls())
# a for loop that prints only odd numbers
for (i in 1:10) {
if ((i %% 2) == 0)
next # pass to next iteration of loop
print(i)
}
############## Practice using break command ####################
# uses break command to break out of a simple loop.
# Author: Lucy Goodyear (lucy.goodyear19@imperial.ac.uk)
# Version: 0.0.1
# clear workspace
rm(list=ls())
# while loop that prints the numbers 1-9
# (breaks out of loop when i is 10)
i <- 0 # initialise i
while (i < Inf) {
if (i == 10) {
break
} # break out of while loop
else {
cat("i equals ", i, "\n")
i <- i + 1 # update i
}
}
############## Practice using break command ####################
# uses break command to break out of a simple loop.
# Author: Lucy Goodyear (lucy.goodyear19@imperial.ac.uk)
# Version: 0.0.1
# clear workspace
rm(list=ls())
# while loop that prints the numbers i equals 1-9
# (breaks out of loop when i is 10)
i <- 0 # initialise i
while (i < Inf) {
if (i == 10) {
break
} # break out of while loop
else {
cat("i equals ", i, "\n")
i <- i + 1 # update i
}
}
