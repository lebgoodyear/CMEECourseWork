Starting weekly assessment for Lucy, Week3

Current Points = 100

Note that: 
(1) Major sections begin with a double "====" line 
(2) Subsections begin with a single "====" line 
(3) Code output or text file content are printed within single "*****" lines 

======================================================================
======================================================================
Your Git repo size this week is about 87.70 MiB on disk 

PART 1: Checking project workflow...

Found the following directories in parent directory: Week6, Week1, Week7, Assessment, C(Week10), Week8, Week5, Week2, Week9, Week4, .git, Week3, MiniProject

Found the following files in parent directory: .gitignore, README.md

Checking for key files in parent directory...

Found .gitignore in parent directory, great! 

Printing contents of .gitignore:
**********************************************************************
*~ 
*.tmp 
*.DS_Store
Week6/Lectures
MiniProject/References
Ecological_Modelling
SeminarDiary.tex
*.log
*-concordance.tex
*.gz
.Rhistory
**********************************************************************

Found README in parent directory, named: README.md

Printing contents of README.md:
**********************************************************************
# CMEE Coursework Repository 2019-2020

*Author: Lucy Goodyear*  
*Created: 10/10/19*  
*Last updated: 04/02/20*

This repository contains all the coursework for the first term of the CMEE Master's course. Each of the main directories contains its own readme detailing the subdirectories, the system requirements to run each script and a description of the contents of each script.

Note that the **C(Week10)** directory does not have the same nomenclature as the other teaching weeks because it is a non-compulsory course for MRes students.

## Table of Contents
1. [Week 1 UNIX and shell scripting](#1.Week-1-UNIX-and-bash-scripting)
2. [Week 2 Python I](#2.Week-2-Python-I)
3. [Week 3 R](#3.Week-3-R)
4. [Week 4 Stats](#4.Week-4-Stats)
5. [Week 5 Modelling and GIS](#5.Week-5-Modelling-and-GIS)
6. [Week 6 Genomics](#6.Week-6-Genomics) 
7. [Week 7 Python II](#7.Week-7-Python-II)
8. [Week 8 MiniProject](#8.Week-8-MiniProject)
9. [Week 9 HPC](#9.Week-9-HPC)
10. [C (Week 10)](#10.C-(Week-10))
11. [MiniProject](#11.Miniproject)
12. [Assessment](#12.Assessment)

### 1. Week 1: UNIX and shell scripting

* FASTA exercise called UnixPrac1.txt
* Simple bash scripts, inlcuding:
    * Counting lines in a file
    * Concatenating the contents of two files
    * Converting tiff to png
    * Converting tab to csv and csv to txt
* LaTeX exercises

### 2. Week 2: Python I

*  Practice scripts exemplifying:
    * types of objects
    * basic functions
    * loops
    * list comprehensions
    * sys.argv
    * control flows
* Practical programming exercises and extra credit

### 3. Week 3: R

* Practice scripts exemplifying:
    * control flows
    * breaks
    * vectorisation
    * preallocation
    * debugging
    * data wrangling
    * plotting using base R, qplot and ggplot
* practical programming exercises

### 4. Week 4: Stats

This directory is empty, created for file structure continuity.

### 5. Week 5: Modelling and GIS

* Four modelling scripts focusing on non-linear least squares
* One GIS script containing GIS practical work

### 6. Week 6: Genomics

* Four scripts: 
    * practical on allele and genotype frequencies
    * practical on on genetic drift, mutation and divergence
    * practical on coalescence theory
    * practical on population subdivision and demographic inferences

### 7. Week 7: Python II

* Practice scripts on profiling
* 4 scripts modeling the Lotka-Voltera system:
    * numerical integration version
    * numerical integration version with carrying capacity
    * discrete time version
    * discrete time steps version with random gaussian fluctuation
* Practicals on visualsing networks
* Practice scripts using regular expressions
* Practice scripts running R scripts from python and accessing command line functions through python

### 8. Week 8: MiniProject

This directory is empty, created for file structure continuity. See MiniProject folder for work done during this week.

### 9. Week 9: HPC

* Main .R script containing all HPC functions on neutral theory and fracals
* Test .R script, which sources the main script and contains suitable parameters to test the functions.
* Cluster .R script which contains the code to be run on the cluster
* A bash script to manage the cluster queue
* Self-sufficient R script containing the answer to question 30 in as few characters as possible

### 10. C (Week 10)

All scripts from C week.

### 11. MiniProject

Work-in-progress scripts for my MiniProject.

### 12. Assessment

Directory for Course Director to push assessment results.**********************************************************************

======================================================================
Looking for the weekly directories...

Found 10 weekly directories: C(Week10), Week1, Week2, Week3, Week4, Week5, Week6, Week7, Week8, Week9

The Week3 directory will be assessed 

======================================================================
======================================================================
PART 2: Checking weekly code and workflow...

======================================================================
Assessing WEEK3...

Found the following directories: Code, Data, Sandbox, Results

Found the following files: README.md

Checking for readme file in weekly directory...

Found README in parent directory, named: README.md

Printing contents of README.md:
**********************************************************************
# CMEE Coursework Week 3 Repository

*Author: Lucy Goodyear*  
*Created: 14/10/19*

This repository contains all the CMEE coursework from Week 3 on R.

**Code** contains the scripts/programs.

**Data** is the data needed to run those scripts.

**Results** is where the outpout from those scripts is sent to.

**Sandbox** is a miscellaneous directory containing experimental code and data.

## Requirements

R v.3.6.1

R packages:
- ggplot2
- reshape2
- ddplyr
- tidyr
- maps
- lattice

Python v.3.7.4

Python packages:
- pandas
- scipy


## List of scripts

1. [basic_io](#1.-basic_io)
2. [control_flow](#2.-control_flow)
3. [break](#3.-break)
4. [next](#4.-next)
5. [boilerplate](#5.-boilerplate)
6. [TreeHeight](#6.-TreeHeight)
7. [Vectorize1(R)](#7.-Vectorize1(R))
8. [preallocate](#8.-preallocate)
9. [apply1](#9.-apply1)
10. [apply2](#10.-apply2)
11. [sample](#11.-sample)
12. [Ricker](#12.-Ricker)
13. [Vectorize2(R)](#13.-Vectorize2(R))
14. [Vectorize1(python)](#14.-Vectorize1(python))
15. [Vectorize2(python)](#15.-Vectorize2(python))
16. [Vectorize_Compare(bash)](#16.-Vectorize_Compare(bash))
17. [try](#17.-try)
18. [browser](#18.-browser)
19. [TAutoCorr](#19.-TAutoCorr)
20. [autocorrelation](#20.-autocorrelation)
21. [DataWrang](#21.-DataWrang)
22. [DataWrangTidy](#22.-DataWrangTidy)
23. [PP_Lattice](#23.-PP_Lattice)
24. [Girko](#24.-Girko)
25. [MyBars](#25.-MyBars)
26. [PlotLin](#26.-PlotLin)
27. [PP_Regress](#27.-PP_Regress)
28. [PP_Regress_Loc](#28.-PP_Regress_Loc)
29. [Mapping](#29.-Mapping)
30. [get_TreeHeight(R)](#30.-get_TreeHeight)
31. [get_TreeHeight(python)](#31.-get_TreeHeight)
32. [run_get_TreeHeight(bash)](#32.-run_get_TreeHeight)


### 1. basic_io

A simple .R script to illustrate R input-output. It loads data from a csv, writes data to a csv and then makes changes to that csv.

###  2. control_flow

A .R script that illustrates different control flow tools.

### 3. break

A .R script that uses ```break``` to break out of a simple loop.

### 4. next

A .R script that uses next to ```skip``` to the next iteration of a loop. The loop checks which numbers between 1 and 10 are odd by using the modulo operation and then all odd numbers are printed. 

### 5. boilerplate

A boilerplate .R script with an example function and test print outs.

### 6. TreeHeight

A .R script that contains a function that calculates heights of trees given the distance of each tree from its base and angle to its top, using the trigonometric formula. This function is called on a sample pair of parameters and then on a loaded data set of trees, the results of which are saved into a csv.

### 7. Vectorize1(R)

A .R script that contains two methods for calculating the sum of a matrix. The first is a function, SumAllElements, containing a for loop and the second is the inbuilt 'sum' function. The prints show which method is faster.

### 8. preallocate

A .R script that contains two methods of creating a matrix, one without using preallocation (function, f) and one using preallocaiton (function, g). The times taken for each function to run are printed to allow comparison.

### 9. apply1

A .R practice script looking at using apply on some of R's inbuilt functions: calculating the means and variance of each row and the means
of each column of a random matrix.

### 10. apply2

A .R script that contains a function that takes one parameter, which, if the sum is greater than 0, is returned multipled by 100. The apply function is used to apply this function to a matrix by row.

### 11. sample

A .R script that contains 6 functions to test the speed of 5 different methods of calculating means. The first function, myexperiment, samples the data and calculates the mean of that sample, the other functions run "num" iterations over myexperiment to generate the means of "num" samples. The functions are then run on identical parameters and timed, with the time taken for each being printed to screen.

### 12. Ricker

A .R script that contains a function called Ricker that runs a simulation of the Ricker model and returns a vector of length generations. The script also plots a line graph showing the model for ten generations.

### 13. Vectorize2(R)

A .R script that contains two functions that run two different simulations of the stochastic (with Gaussian fluctuations) Ricker equation. One contains two for loops, stochrick, the other, stochrickvect, has been vectorised. The times taken for the two models to run are compared at the end.

### 14. Vectorize1(python)

A .py script that contains two methods for calculating the sum of a matrix. The first is a function, SumAllElements, containing a for loop and the second is the inbuilt 'sum' function. The prints show which method is faster.

### 15. Vectorize2(python)

A .py script that contains two functions that run two different simulations of the stochastic (with Gaussian fluctuations) Ricker equation. One contains two for loops, stochrick, the other, stochrickvect, has been vectorised. The times taken for the two models to run are compared at the end.

### 16. Vectorize_Compare(bash)

A .sh script that runs the four Vectorize scripts (2 R scripts and 2 python scripts) that run loops and vectorized versions
of blocks of code, comparing the times for each script.

### 17. try

A .R script to practise catching errors and debugging. It contains one function with a custom made error.

### 18. browser

A practice .R script that inserts a breakpoint into the code and enters browser mode.

### 19. TAutoCorr

A .R script that loads and plots a dataset of temperatures by year in Key West. It creates two lists offset from each other by one year, which allows the correltaion to be calculated for successive years. It then calculates the correlation coefficient for 10,000 random permutations of the temperature in order to compare significance.

### 20. autocorrelation

A .Rnw script that produces a pdf from latex code with the embedded TAutoCorr R script. It includes the graph of the temperatures in Key West data set, the autocorrelation results, including a histogram of the frequency of correlation results over the 10,000 random permutations, and a summary of the results and conclusions drawn. A pdf of the same name and contents is stored in the **Results** directory.

### 21. DataWrang

A .R script that wrangles a dataset called "PoundHillData" found in the **Data** directory. It processes the data to turn it into a format that we can manipulate and visualise.

### 22. DataWrangTidy

A .R script based on DataWrang.R (described above). The ```reshape2``` package has been replaced with the ```dplyr``` package and corresponding commands have been modified accordingly.

### 23. PP_Lattice

A .R script that uses a dataset containing predator-prey body size information to plot 3 lattice graphs showing predator and prey masses and the ratio between them by types of food interaction. It also calculates mean and median for the above subsets and saves the results to a csv.

### 24. Girko

A .R script that plots Girko's circular law and saves figure as a pdf. It first builds a function that returns an ellipse then and produces a N by N matrix containing randomly normally distributed values. The eigenvalues are calulcated for this matrix and then plotted on an Argand diagram (real numbers on the x-axis and imaginary numbers on the y-axis). Onto this Argand diagram, adds an ellipe with a radius of square root of N to show how the points fit into the shape of this ellipse.

### 25. MyBars

A .R script that loads data from a .txt file and plots it as three line ranges (using ggplot2) with annotations for particular values.

### 26. PlotLin

A .R script that performs a linear regression on some sample data, plots the data with the regression line and then annotates the plot with a mathematical equation. This is then saved as pdf into the **Results** directory.

### 27. PP_Regress

A .R script that plots graphs from predator and prey size data, including linear regressions, differentiated by predator lifestage, facected by type of feeding interaction and saves to pdf. It also calculates linear regression results corresponding to the lines fitted in the figure and saves as csv demlimited table.

### 28. PP_Regress_Loc

A .R script that calculates linear regression model for predator and prey masses separated by type of feeding interaction, predator lifestage and location and then saves results as csv demlimited table.

### 29. Mapping

A .R script that plots a map showing spaital spread of species from a loaded dataset. It plots an empty world map using the maps package and adds data points from the dataset, which contains species and corresponding longitudes and latitudes. It contains comments on possible biases.

### 30. get_TreeHeight(R)

This .R script contains a function, TreeHeight, that calculates heights of trees given the distance of each tree from its base and angle to its top, using the trigonometric formula. This function is called on data from a csv file, which has been provided by the user as a command line argument, the results of which are added as an additional column to the dataframe. The new dataframe is saved as a csv, the name of which includes the basename of the input csv.

### 31. get_TreeHeight(python)

A .py script that contains a function, TreeHeight, which calculates heights of trees given the distance of each tree from its base and angle to its top, using the trigonometric formula. In the main function, the TreeHeight function is called  on data from a csv, which has previously been provided by the user as a command line argument and then loaded as a pandas dataframe. The returns from the TreeHeight function call are added as an additional column to the dataframe, which is saved as a new csv file. The main function also strips the csv command line argument of its relative path and extension and uses that basename as the name of the resulting csv.

### 32. run_get_TreeHeight(bash)

A .sh script that runs an R-script and a python script that calculate tree heights for a data set provided externally to the two scripts. Both scripts produce the same resultant csv file, which is saved into the **Results** directory.**********************************************************************

Found following files in results directory: TreeHts.csv, Girko.pdf, PP_Results.csv, PP_Regress_Results.csv, PP_Regress.pdf, PP_Regress_Loc_Results.csv, autocorrelation.pdf, Pred_Lattice.pdf, Prey_Lattice.pdf, MyLinReg.pdf, README.md, SizeRatio_Lattice.pdf, trees_treeheights_R.csv, MyBars.pdf, MyData.csv...
ideally, Results directory should be empty other than, perhaps, a readme. 

Found 31 code files: PP_Regress.R, Vectorize2.py, apply1.R, sample.R, Vectorize_Compare.sh, control_flow.R, run_get_TreeHeight.sh, get_TreeHeight.py, Mapping.R, boilerplate.R, TreeHeight.R, PP_Lattice.R, PlotLin.R, next.R, Ricker.R, Girko.R, Vectorize1.R, break.R, basic_io.R, Vectorize1.py, try.R, apply2.R, get_TreeHeight.R, TAutoCorr.R, browser.R, Vectorize2.R, DataWrangTidy.R, preallocate.R, PP_Regress_loc.R, DataWrang.R, MyBars.R

Found the following extra files: Rplots.pdf, autocorrelation.Rnw
0.5 pt deducted per extra file

Current Points = 99.0

======================================================================
Testing script/code files...

======================================================================
Inspecting script file PP_Regress.R...

File contents are:
**********************************************************************
################### Calculating a linear model for predator and prey masses #####################
############################ by feeding type and predator lifestage #############################

# Plots graphs from predator and prey size data, including linear regressions,
# differentiated by predator lifestage, facected by type of feeding interaction and saves to pdf.
# Calculates regression results corresponding to the lines fitted in the figure and saves as
# csv demlimited table.

# Author: Lucy Goodyear (lucy.goodyear19@imperial.ac.uk)
# Version: 0.0.1

# clear workspace
rm(list=ls())

# imports
library(ggplot2)
library(dplyr)

# load the data
MyDF <- read.csv("../Data/EcolArchives-E089-51-D1.csv")
dim(MyDF) # check the size of the data frame you loaded

# convert masses in mg to g
for (i in 1:nrow(MyDF)){
  if (MyDF$Prey.mass.unit[i] == "mg"){
    MyDF$Prey.mass.unit[i] = "g"
    MyDF$Prey.mass[i] = MyDF$Prey.mass[i] / 1000
  }
}

pdf("../Results/PP_Regress.pdf", # open blank pdf page using a relative path
    8.3, 11.7)  # page dimensions in inches

# plot the predator and prey mass by feeding type and predator lifestage using the linear model method
qplot(Prey.mass, Predator.mass, data = MyDF, log="xy",
      xlab = "Prey mass in grams",
      ylab = "Predator mass in grams",
      colour = Predator.lifestage, shape = I(3)) +
      geom_smooth(method = "lm",fullrange = TRUE) + # plot linear regressions
      facet_grid(Type.of.feeding.interaction~.) + # all plots on the same grid
      theme_bw() %+replace% 
      theme(legend.position = "bottom",
            panel.border = element_rect(colour = "grey", fill = NA)) +
      guides(colour = guide_legend(nrow = 1)) + # put legend on one line
      theme(legend.title = element_text(size = 9, face="bold"))

graphics.off() # close all open devices/windows

# calculate the regression results corresponding to the lines fitted in the figure
LM <- MyDF %>% 
         # first remove subset that contains only 2 examples, both with same species of prey and predator, 
         # because f-statistic can't be calculated on this (and no linear regression line can be drawn)
         filter(Record.number != "30914" & Record.number != "30929") %>%
         # subset only the data needed and group by feeeding type and predator lifestage
         dplyr::select(Record.number, Predator.mass, Prey.mass, Predator.lifestage, Type.of.feeding.interaction) %>%
         group_by(Type.of.feeding.interaction, Predator.lifestage) %>%
         # do linear model calculations and store specific values as columns to dataframe
         do(mod=lm(Predator.mass ~ Prey.mass, data = .)) %>%
         mutate(Regression.slope = summary(mod)$coeff[2],
                Regression.intercept = summary(mod)$coeff[1],
                R.squared = summary(mod)$adj.r.squared,
                Fstatistic = summary(mod)$fstatistic[1],
                P.value = summary(mod)$coeff[8]) %>%
         dplyr::select(-mod) # remove column created by mod=lm command

# save the regression results to a csv delimited table
write.csv(LM, "../Results/PP_Regress_Results.csv")
**********************************************************************

Testing PP_Regress.R...

Output (only first 500 characters): 

**********************************************************************
[1] 34931    15

**********************************************************************

Encountered error (or warning):

Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

Warning message:
In qt((1 - level)/2, df) : NaNs produced

======================================================================
Inspecting script file Vectorize2.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

"""
Contains two functions that run two different simulations of the stochastic 
(with Gaussian fluctuations) Ricker equation. One contains two for loops, stochrick,
the other, stochrickvect, has been vectorised. The times taken for the two models 
to run are compared at the end.
"""

__author__ = 'Lucy Goodyear (lucy.goodyear19@imperial.ac.uk)'
__version__ = '0.0.1'

# imports
import scipy as sc
import scipy.stats as scs
import time

# define stochastic (with Gaussian fluctuations) Ricker equation with two for loops

def stochrick(p0=sc.random.uniform(.5,1.5,size=1000),r=1.2,K=1,sigma=0.2,numyears=100):
    '''Runs a simulation of the stochastic Ricker equation, looping over
    each population and each year, adding the gaussian fluctuation to 
    each population separately.

    Parameters:
        p0 (array) : initial populaiton denisty
        r (float) : intrinsic growth rate
        K (float) : carrying capacity
        sigma (float) : gaussian fluctuation
        numyear (integer) : number of years to loop over

    Returns:

        N (array) : population density after numyears have passed

    '''
  
    # initialise matrix of zeros
    N = sc.zeros((numyears, len(p0)))
    # set initial population density
    N[1,] = p0
  
    for pop in range(1, len(p0)): #loop through the populations

        for yr in range(2, numyears): #for each pop, loop through the years

            N[yr][pop] = N[yr-1][pop] * sc.exp(r*(1-(N[yr-1][pop]/K))) + sc.random.normal(0, sigma, 1)
    
    return N

# Now write another function called stochrickvect that vectorizes the above 
# to the extent possible, with improved performance: 

def stochrickvect(p0=sc.random.uniform(.5,1.5,size=1000),r=1.2,K=1,sigma=0.2,numyears=100):
    '''Runs a simulation of the stochastic Ricker equation, looping over
    each year and adding the gaussian fluctuation (as an array) to all populations at once
    each year.

    Parameters:
        p0 (array) : initial populaiton denisty
        r (float) : intrinsic growth rate
        K (float) : carrying capacity
        sigma (float) : gaussian fluctuation
        numyear (integer) : number of years to loop over

    Returns:

        N (array) : population density after numyears have passed

    '''

    # initialise matrix of zeros
    N = sc.zeros((numyears,len(p0)))
    # set initial population density
    N[1] = p0
  
    for yr in range(2, numyears): # loops through populations by year
      
        N[yr,] = N[yr-1,] * sc.exp(r * (1 - (N[yr-1,] / K))) + sc.random.normal(0, sigma, size = len(p0))
    
    return N 

# compare times for calling the vectorised and non-vectorised functions
start = time.time()
stochrick(p0=sc.random.uniform(.5,1.5,size=1000),r=1.2,K=1,sigma=0.2,numyears=100)
end = time.time()
print("For Stochastic Ricker using 2 for loops, the time taken is:")
print(end - start)

start = time.time()
stochrickvect(p0=sc.random.uniform(.5,1.5,size=1000),r=1.2,K=1,sigma=0.2,numyears=100)
end = time.time()
print("For Stochastic Ricker adding all stochastic terms at once, the time taken is:")
print(end - start)

**********************************************************************

Testing Vectorize2.py...

Vectorize2.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Missing docstring, either in one or functions and/or at the script level

Current Points = 98.0

Output (only first 500 characters): 

**********************************************************************
For Stochastic Ricker using 2 for loops, the time taken is:
0.6016080379486084
For Stochastic Ricker adding all stochastic terms at once, the time taken is:
0.007687807083129883

**********************************************************************

Encountered error (or warning):
Vectorize2.py:79: RuntimeWarning: overflow encountered in exp
  N[yr,] = N[yr-1,] * sc.exp(r * (1 - (N[yr-1,] / K))) + sc.random.normal(0, sigma, size = len(p0))

======================================================================
Inspecting script file apply1.R...

File contents are:
**********************************************************************
######## Practice script looking at using apply on some of R's inbuilt functions ########

# Uses the apply function to calculate the means and variance of each row and the means
# of each column of a random matrix.

# Author: Lucy Goodyear (lucy.goodyear19@imperial.ac.uk)
# Version: 0.0.1

# clear workspace
rm(list=ls())

# build a random matrix
M <- matrix(rnorm(100), 10, 10)

# take the mean of each row
RowMeans <- apply(M, 1, mean)
print(RowMeans)

# now take the variance
RowVars <- apply(M, 1 ,var)
print(RowVars)

# take means by column
ColMeans <- apply(M, 2, mean)
print(ColMeans)
**********************************************************************

Testing apply1.R...

Output (only first 500 characters): 

**********************************************************************
 [1] -0.26338396 -0.06992591  0.35983527  0.40086613  0.49844667 -0.40122980
 [7]  0.26967299 -0.23441241  0.24549827 -0.47012934
 [1] 1.6233395 1.5328256 1.0148828 0.3352176 0.9070189 0.5374317 1.1077654
 [8] 1.3539874 0.3410623 1.7015434
 [1] -0.33003348  0.36795342  0.15974414 -0.12858206 -0.09238677 -0.01424874
 [7] -0.28738389  0.38391534  0.23098751  0.04527245

**********************************************************************

Code ran without errors

Time consumed = 0.10045s

======================================================================
Inspecting script file sample.R...

File contents are:
**********************************************************************
######### run a simulation that involves sampling from a population #########

# Contains 6 functions to test the speed of 5 different methods of calculating 
# means. The first function, myexperiment, samples the data and calculates
# the mean of that sample, the other functions run "num" iterations over 
# myexperiment to generate the means of "num" samples. The functions are then
# run on identical parameters and timed, with the time taken for each being 
# printed to screen.

# Author: Lucy Goodyear (lucy.goodyear19@imperial.ac.uk)
# Version: 0.0.1

# clear workspace
rm(list=ls())

# a function to take a sample of size n from a population "popn" and return its mean
myexperiment <- function(popn, n){
    pop_sample <- sample(popn, n, replace = FALSE)
    return(mean(pop_sample))
}

# calculate means using a loop without preallocation
loopy_sample1 <- function(popn, n, num) {
    result1 <- vector() # initialise empty vector of size 1
    for (i in 1:num){
        result1 <- c(result1, myexperiment(popn, n))
    }
    return(result1)
}

# to run "num" iterations of the experiment using a for loop on a vector with preallocation
loopy_sample2 <- function(popn, n, num) {
    result2 <- vector(,num) # preallocate expected size
    for (i in 1:num) {
        result2[i] <- myexperiment(popn, n)
    }
    return(result2)
}

# to run "num" iterations of the experiment using a for loop on a list with preallocation
loopy_sample3 <- function(popn, n, num) {
    result3 <- vector("list", num) # preallocate expected size
    for (i in 1:num) {
        result3[[i]] <- myexperiment(popn, n)
    }
    return(result3)
}

# to run "num" iterations of the experiment using vectorisation with lapply
lapply_sample <- function(popn, n, num) {
    result4 <- lapply(1:num, function(i) myexperiment(popn, n))
    return(result4)
}

# to run "num" iterations of the experiment using vectorisation with sapply
sapply_sample <- function(popn, n, num) {
    result5 <- sapply(1:num, function(i) myexperiment(popn, n))
    return(result5)
}

# generate the population
popn <- rnorm(1000)
hist(popn)

n <- 20 # sample size for each experiment
num <- 1000 # number of times to rerun the experiment

# time each function and print time to screen
print("The loopy, non-preallocation approach takes:")
print(system.time(loopy_sample1(popn, n, num)))

print("The loopy, but with preallocation approach takes:")
print(system.time(loopy_sample2(popn, n, num)))

print("The loopy, non-preallocation approach takes:")
print(system.time(loopy_sample3(popn, n, num)))

print("The vectorized lapply approach takes:")
print(system.time(sapply_sample(popn, n, num)))

print("The vectorized sapply approach takes:")
print(system.time(sapply_sample(popn, n, num)))
**********************************************************************

Testing sample.R...

Output (only first 500 characters): 

**********************************************************************
[1] "The loopy, non-preallocation approach takes:"
   user  system elapsed 
  0.028   0.004   0.033 
[1] "The loopy, but with preallocation approach takes:"
   user  system elapsed 
  0.012   0.000   0.014 
[1] "The loopy, non-preallocation approach takes:"
   user  system elapsed 
  0.012   0.000   0.012 
[1] "The vectorized lapply approach takes:"
   user  system elapsed 
  0.012   0.000   0.010 
[1] "The vectorized sapply approach takes:"
   user  system elapsed 
  0.012   0.000   0.013 

**********************************************************************

Code ran without errors

Time consumed = 0.29451s

======================================================================
Inspecting script file Vectorize_Compare.sh...

File contents are:
**********************************************************************
#!/bin/bash
# Author: Lucy Goodyear lucy.goodyear19@imperial.ac.uk
# Script: Vectorize_Compare.sh
# Desc: runs 2 R scripts and 2 python scripts that run loops and vectorized versions
# of blocks of code, comparing times.
# Arguments: None
# Date: Dec 2019

# compare running times for Vectorize1 in python and R
printf "\nRunning Vectorize1.py\n"
TIMEFORMAT='Vectorize1 in python: time taken is '%R
time python3 Vectorize1.py
printf "\nRunning Vectorize1.R\n"
TIMEFORMAT='Vectorize1 in R: time taken is '%R
time Rscript Vectorize1.R

# compare running times for Vectorize2 in python and R
printf "\nRunning Vectorize2.py\n"
TIMEFORMAT='Vectorize2 in python: time taken is '%R
time python3 Vectorize2.py
printf "\nRunning Vectorize2.R\n"
TIMEFORMAT='Vectorize2 in R: time taken is '%R
time Rscript Vectorize2.R**********************************************************************

Testing Vectorize_Compare.sh...

Output (only first 500 characters): 

**********************************************************************

Running Vectorize1.py
Using loops, the time taken is:
0.18587088584899902
Using in-built scipy sum function, the time taken is:
0.0005955696105957031

Running Vectorize1.R
[1] "Using loops, the time taken is: 0.08"
[1] "Using the in-built vectorized function, the time taken is: 0.000999999999999973"

Running Vectorize2.py
For Stochastic Ricker using 2 for loops, the time taken is:
0.6275999546051025
For Stochastic Ricker adding all stochastic terms at once, the time taken is:
0.00768518447875976
**********************************************************************

Encountered error (or warning):
Vectorize1 in python: time taken is 0.561
Vectorize1 in R: time taken is 0.252
Vectorize2.py:79: RuntimeWarning: overflow encountered in exp
  N[yr,] = N[yr-1,] * sc.exp(r * (1 - (N[yr-1,] / K))) + sc.random.normal(0, sigma, size = len(p0))
Vectorize2 in python: time taken is 0.973
Vectorize2 in R: time taken is 0.371

======================================================================
Inspecting script file control_flow.R...

File contents are:
**********************************************************************
####### Practice using different control flow tools ########

# illustrates different control flow tools.

# Author: Lucy Goodyear (lucy.goodyear19@imperial.ac.uk)
# Version: 0.0.1

# clear workspace
rm(list=ls())

# if statement
a <- TRUE
if (a == TRUE){
    print ("a is TRUE")
    } else {
    print ("a is FALSE")
}

# if statement on a single line
z <- runif(1) # uniformly distributed random number
if (z <= 0.5) {print ("Less than a half")}

# for loop using a sequence
for (i in 1:10){
    j <- i * i
    print(paste(i, " squared is", j ))
}

# for loop over vector of strings
for(species in c('Heliodoxa rubinoides',
                 'Boissonneausa jardini',
                 'Sula nebouxii')){
    print(paste('The species is', species))
}

# for loop using a vector
v1 <- c("a","bc","def")
for (i in v1){
    print(i)
}

# while loop
i <- 0
while (i < 10){
    i <- i + 1
    print(i^2)
}
**********************************************************************

Testing control_flow.R...

Output (only first 500 characters): 

**********************************************************************
[1] "a is TRUE"
[1] "1  squared is 1"
[1] "2  squared is 4"
[1] "3  squared is 9"
[1] "4  squared is 16"
[1] "5  squared is 25"
[1] "6  squared is 36"
[1] "7  squared is 49"
[1] "8  squared is 64"
[1] "9  squared is 81"
[1] "10  squared is 100"
[1] "The species is Heliodoxa rubinoides"
[1] "The species is Boissonneausa jardini"
[1] "The species is Sula nebouxii"
[1] "a"
[1] "bc"
[1] "def"
[1] 1
[1] 4
[1] 9
[1] 16
[1] 25
[1] 36
[1] 49
[1] 64
[1] 81
[1] 100

**********************************************************************

Code ran without errors

Time consumed = 0.13273s

======================================================================
Inspecting script file run_get_TreeHeight.sh...

File contents are:
**********************************************************************
#!/bin/bash
# Author: Lucy Goodyear lucy.goodyear19@imperial.ac.uk
# Script: run_get_TreeHeight.sh
# Desc: runs an R script and a python script that calculate tree heights
# for a data set provided externally to the two scripts. Both scripts 
# produce the same resultant csv file.
# Arguments: None
# Date: Nov 2019

# run R script with trees.csv as an example
echo "Running R script"
Rscript get_TreeHeight.R ../Data/trees.csv
echo "R script finished"

# run python script with trees.csv as an example
echo "Running python script"
python3 get_TreeHeight.py ../Data/trees.csv
echo "Python script finished"**********************************************************************

Testing run_get_TreeHeight.sh...

Output (only first 500 characters): 

**********************************************************************
Running R script
R script finished
Running python script
Python script finished

**********************************************************************

Encountered error (or warning):
Traceback (most recent call last):
  File "get_TreeHeight.py", line 69, in <module>
    main(Tree_data)
  File "get_TreeHeight.py", line 60, in main
    Tree_data.to_csv(Path(Path('../Results/'), Path(sys.argv[1]).stem + '_treeheights_py.csv'))
  File "/usr/lib/python3/dist-packages/pandas/core/frame.py", line 1332, in to_csv
    formatter.save()
  File "/usr/lib/python3/dist-packages/pandas/core/format.py", line 1481, in save
    compression=self.compression)
  File "/usr/lib/python3/dist-packages/pandas/io/common.py", line 354, in _get_handle
    f = open(path, mode, errors='replace')
TypeError: invalid file: PosixPath('../Results/trees_treeheights_py.csv')

======================================================================
Inspecting script file get_TreeHeight.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" 
Contains a function, TreeHeight, that calculates heights of trees given the distance of each tree from its base 
and angle to its top, using the trigonometric formula. In the main function, the TreeHeight function is called 
on data from a csv, which has previously been provided by the user as a command line argument and then loaded 
as a pandas dataframe. The returns from the TreeHeight function call are added as an additional column to the dataframe, 
which is saved as a new csv file. The main function also strips the csv command line argument of its relative path 
and extension and uses that basename as the name of the resulting csv.

"""

__author__ = 'Lucy Goodyear (lucy.goodyear19@imperial.ac.uk)'
__version__ = '0.0.1'

# imports
import sys
import scipy as sc
import pandas as pd
from pathlib import Path

# define function to caluclate tree height
def TreeHeight(degrees, distance):
    '''
    Calculates heights of trees given the distance
    of each tree from its base and angle to its top, using the 
    trigonometric formula

    height = distance * tan(radians)

    Parameters:
        degrees (float) : The angle of elevation of tree
        distance (float) : The distance from base of tree (e.g. metres)

    Returns:
        height (float) : the heights of the trees, same units as "distance"

    '''
    radians = degrees * sc.pi / 180
    height = distance * sc.tan(radians)
    # commented out print function below to improve speed with large datasets
    #print(paste("Tree height is", height))

    return(height)

# define main programme as main function to enable arguments to be set from the command line
def main(Tree_data):
    '''
    Calls the TreeHeight function on data from a csv, which has previously been provided by the user
    as a command line argument and then loaded as a pandas dataframe. The returns from the 
    function call are added as an additional column to the dataframe, which is saved as a new csv file.
    It strips the csv command line argument of its relative path and extension and uses that basename 
    as the name of the resulting csv.
    '''
    
    # add column to Tree_data to include tree heights, calculated by the TreeHeight function
    Tree_data["Tree.Height.m"] = Tree_data.apply(lambda x: TreeHeight(x["Distance.m"], x["Angle.degrees"]), axis = 1)

    # write data to csv using the input filename (removing relative path and extension and then adding the new ones)
    Tree_data.to_csv(Path(Path('../Results/'), Path(sys.argv[1]).stem + '_treeheights_py.csv'))

if __name__ == "__main__":
    # use data file provided by user in command line
    if len(sys.argv) == 1:
        print("No input file detected: please provide a data file")
        exit()
    else:
        Tree_data = pd.read_csv(sys.argv[1])
        main(Tree_data)
**********************************************************************

Testing get_TreeHeight.py...

get_TreeHeight.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Missing docstring, either in one or functions and/or at the script level

Current Points = 97.0

Output (only first 500 characters): 

**********************************************************************
No input file detected: please provide a data file

**********************************************************************

Code ran without errors

Time consumed = 0.37055s

======================================================================
Inspecting script file Mapping.R...

File contents are:
**********************************************************************
##### Plots a map showing spaital spread of species from dataset #######
########################################################################

# plots an empty world map using the maps package and adds data points
# from a dataset containing species and corresponding longitudes and 
# latitudes

# Author: Lucy Goodyear (lucy.goodyear19@imperial.ac.uk)
# Version: 0.0.1

# clear workspace
rm(list=ls())

#imports
library(maps)

# load the data
load("../Data/GPDDFiltered.RData")

# plot the map using the maps package
map(database = "world", fill=TRUE, col="darkolivegreen3", 
    bg = "cadetblue2", ylim = c(-60,90), border = "grey66")
# plot the data points onto the map
points(x = gpdd$long, y = gpdd$lat, col = "black", pch = 1, cex = 0.35)        

# Expected biases:
# Spatial bias!
# 1) Data points are from temperate regions so no weighting
# from tropical species (however analysis may be specifically
# focused on species from temperate regions)
# 2) Most data is from UK or the west coast of USA, not representative
# of actual biodiversity of species across temperate regions

**********************************************************************

Testing Mapping.R...

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.43784s

======================================================================
Inspecting script file boilerplate.R...

File contents are:
**********************************************************************
################## boilerplate R script ######################

# Contains an example function and test print outs.

# Author: Lucy Goodyear (lucy.goodyear19@imperial.ac.uk)
# Version: 0.0.1

# clear workspace
rm(list=ls())

MyFunction <- function(Arg1, Arg2){

    # statements involving Arg1, Arg2
    print(paste("Argument", as.character(Arg1), "is a", class(Arg1))) # print Arg1's type
    print(paste("Argument", as.character(Arg2), "is a", class(Arg2))) # print Arg2's type

    return (c(Arg1, Arg2)) # this is optional but very useful
}

MyFunction(1, 2) # test the function
MyFunction("Riki", "Tiki") # a different test

**********************************************************************

Testing boilerplate.R...

Output (only first 500 characters): 

**********************************************************************
[1] "Argument 1 is a numeric"
[1] "Argument 2 is a numeric"
[1] 1 2
[1] "Argument Riki is a character"
[1] "Argument Tiki is a character"
[1] "Riki" "Tiki"

**********************************************************************

Code ran without errors

Time consumed = 0.12203s

======================================================================
Inspecting script file TreeHeight.R...

File contents are:
**********************************************************************
################## Calculate tree heights #####################

# Contains a function that calculates heights of trees, which 
# is called on a sample pair of parameters and then on a 
# loaded data set of trees, the results of which are saved into a csv.

# The function calculates heights of trees given the distance
# of each tree from its base and angle to its top, using the 
# trigonometric formula

# height = distance * tan(radians)

# Arguments:
# degrees: The angle of elevation of tree
# distance: The distance from base of tree (e.g. metres)

# Output:
# the heights of the trees, same units as "distance"

# Author: Lucy Goodyear (lucy.goodyear19@imperial.ac.uk)
# Version: 0.0.1

# clear workspace
rm(list=ls())

# loads data from a csv
Tree_data <- read.csv("../Data/trees.csv")

TreeHeight <- function(degrees, distance){
    radians <- degrees * pi / 180
    height <- distance * tan(radians)
    # commented out print function below to improve speed with large datasets
    #print(paste("Tree height is", height))

    return(height)
}

TreeHeight(37, 40) # sample values

# add column to Tree_data to include tree heights, calculated by the TreeHeight function
Tree_data$Tree.Height.m <- TreeHeight(Tree_data$Angle.degrees, Tree_data$Distance.m)

# write data to a csv
write.csv(Tree_data, "../Results/TreeHts.csv")

**********************************************************************

Testing TreeHeight.R...

Output (only first 500 characters): 

**********************************************************************
[1] 30.14216

**********************************************************************

Code ran without errors

Time consumed = 0.12744s

======================================================================
Inspecting script file PP_Lattice.R...

File contents are:
**********************************************************************
############################# Plotting lattice graphs ##################################
######################## and calculating means and medians ##############################

# Using a dataset containing predator-prey body size information to plot 3 lattice graphs 
# showing predator and prey masses and the ratio between them by types of food interaction.
# Also calculates mean and median for the above subsets and saves to csv.

# Author: Lucy Goodyear (lucy.goodyear19@imperial.ac.uk)
# Version: 0.0.1

# clear workspace
rm(list=ls())

# imports
library(lattice)
library(dplyr)

# load the data
PPDataFrame <- read.csv("../Data/EcolArchives-E089-51-D1.csv")

# convert masses in mg to g
for (i in 1:nrow(PPDataFrame)){
  if (PPDataFrame$Prey.mass.unit[i] == "mg"){
    PPDataFrame$Prey.mass.unit[i] = "g"
    PPDataFrame$Prey.mass[i] = PPDataFrame$Prey.mass[i] / 1000
  }
}

# plot a lattice plot of predator mass by type feeding interation and save as pdf
pdf("../Results/Pred_Lattice.pdf", # open blank pdf page using a relative path
    11.7, 8.3) # these numbers are page dimensions in inches
densityplot(~log(Predator.mass) | Type.of.feeding.interaction, data = PPDataFrame)

graphics.off()

# plot a lattice plot of prey mass by type feeding interation and save as pdf
pdf("../Results/Prey_Lattice.pdf",
    11.7, 8.3)
densityplot(~log(Prey.mass) | Type.of.feeding.interaction, data = PPDataFrame)

graphics.off()

# plot a lattice plot of the size ratio of prey mass over predator mass by type feeding interation and save as pdf
pdf("../Results/SizeRatio_Lattice.pdf",
    11.7, 8.3) 
densityplot(~log(Prey.mass/Predator.mass) | Type.of.feeding.interaction, data = PPDataFrame)

graphics.off()

# save to csv mean and median of predator mass, prey mass, and size ratio by type of feeding interaction
# using ddplyr and grouping by type of feeding interaction
Averages <- PPDataFrame %>%
            group_by(Type.of.feeding.interaction) %>%
            summarise(mean(log(Predator.mass)), 
                      median(log(Predator.mass)),
                      mean(log(Prey.mass)),
                      median(log(Prey.mass)),
                      mean(log(Prey.mass/Predator.mass)),
                      median(log(Prey.mass/Predator.mass)))

# set column names
names(Averages) <- c("Feeding.Type", 
                    "Mean:log.of.predator.mass",
                    "Median:log.of.predator.mass",
                    "Mean:log.of.prey.mass",
                    "Median:log.of.prey.mass",
                    "Mean:log.of.prey.mass/predator.mass",
                    "Median:log.of.prey.mass/predator.mass")

# save to csv
write.csv(Averages, "../Results/PP_Results.csv")

**********************************************************************

Testing PP_Lattice.R...

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error (or warning):

Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union


======================================================================
Inspecting script file PlotLin.R...

File contents are:
**********************************************************************
######## Mathematical notation on an axis and in plot area ##############

# performs a linear regression on some sample data, plots the data with 
# the regression line and then annotates the plot with a mathematical equation.

# Author: Lucy Goodyear (lucy.goodyear19@imperial.ac.uk)
# Version: 0.0.1

# clear workspace
rm(list=ls())

# imports
library(ggplot2)

# create some linear regression data
x <- seq(0, 100, by = 0.1)
y <- -4. + 0.25*x + 
    rnorm(length(x), mean = 0., sd = 2.5)

# put data in a dataframe
my_data <- data.frame(x = x, y = y)

# perform a linear regression
my_lm <- summary(lm(y ~ x, data = my_data))

# plot the data
p <- ggplot(my_data, aes(x = x, 
                         y = y,
                         colour = abs(my_lm$residual))) +
            geom_point() +
            scale_colour_gradient(low = "black", high = "red") +
            theme(legend.position = "none") +
            scale_x_continuous(expression(alpha^2 * pi / beta * sqrt(Theta)))

# add regresssion line
p <- p + geom_abline(intercept = my_lm$coefficients[1][1],
                     slope = my_lm$coefficients[2][1],
                     colour = "red")

# put the mathematical equation on the plot
p <- p + geom_text(aes(x = 60,
                       y = 0,
                       label = "sqrt(alpha) * 2 * pi"),
                       parse = TRUE,
                       size = 6,
                       colour = "blue")

# save result into a pdf
pdf("../Results/MyLinReg.pdf")
p + ggtitle("Plot with mathematical display")
dev.off()

**********************************************************************

Testing PlotLin.R...

Output (only first 500 characters): 

**********************************************************************
null device 
          1 

**********************************************************************

Code ran without errors

Time consumed = 1.36519s

======================================================================
Inspecting script file next.R...

File contents are:
**********************************************************************
############## Practice using next command ####################

# Uses next to skip to the next iteration of a loop.
# The loop checks which numbers between 1 and 10 are odd by 
# using the modulo operation and then all odd numbers are printed. 

# Author: Lucy Goodyear (lucy.goodyear19@imperial.ac.uk)
# Version: 0.0.1

# clear workspace
rm(list=ls())

# a for loop that prints only odd numbers
for (i in 1:10) {
    if ((i %% 2) == 0)
        next # pass to next iteration of loop
    print(i)
}**********************************************************************

Testing next.R...

Output (only first 500 characters): 

**********************************************************************
[1] 1
[1] 3
[1] 5
[1] 7
[1] 9

**********************************************************************

Code ran without errors

Time consumed = 0.10570s

======================================================================
Inspecting script file Ricker.R...

File contents are:
**********************************************************************
############### A simulation of the Ricker model ################

# Contains a function called Ricker that runs a simulation of the 
# Ricker model and returns a vector of length generations. The script
# also plots a line graph showing the model for ten generations.

# Author: Lucy Goodyear (lucy.goodyear19@imperial.ac.uk)
# Version: 0.0.1

# clear workspace
rm(list=ls())

Ricker <- function(N0 = 1, r = 1, K = 10, generations = 50) {
  
  # runs a simulation of the Ricker model
  # returns a vector of length generations
  
  N <- rep(NA, generations) # creates a vector of NA
  
  N[1] <- N0
  for (t in 2: generations) {
      N[t] <- N[t-1] * exp(r * (1.0 - (N[t-1] / K)))
  }
  return (N)
}

# plot a line graph of the Ricker function with 10 generations
plot(Ricker(generations = 10), type = "l")
  **********************************************************************

Testing Ricker.R...

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.16205s

======================================================================
Inspecting script file Girko.R...

File contents are:
**********************************************************************
#################### Plotting Girko's Circular Law #################################

# Plots Girko's circular law and saves figure as a pdf. It first builds a function
# that returns an ellipse then and produces a N by N matrix containing randomly 
# normally distributed values. The eigenvalues are calulcated for this matrix and 
# then plotted on an Argand diagram (real numbers on the x-axis and imaginary 
# numbers on the y-axis). Onto this Argand diagram, adds an ellipe with a radius of 
# square root of N to show how the points fit into the shape of this ellipse.

# Author: Lucy Goodyear (lucy.goodyear19@imperial.ac.uk)
# Version: 0.0.1

# clear workspace
rm(list=ls())

# imports
library(ggplot2)

build_ellipse <- function(hradius, vradius){ # function that returns an ellipse
    npoints = 250
    a <- seq(0, 2 * pi, length = npoints + 1)
    x <- hradius * cos(a)
    y <- vradius * sin(a)
    return(data.frame(x = x, y= y))
} 

N <- 250 # assign size of matrix

M <- matrix(rnorm(N * N), N, N) # build the matrix

eigvals <- eigen(M)$values # find the eigenvalues

eigDF <- data.frame("Real" = Re(eigvals), "Imaginary" = Im(eigvals)) # build a dataframe

my_radius <- sqrt(N) # The radius of the circle is sqrt(N)

ellDF <- build_ellipse(my_radius, my_radius) # dataframe to plot the ellipse

names(ellDF) <- c("Real", "Imaginary") # rename the columns

# plot the eigenvalues
p <- ggplot(eigDF, aes(x = Real, y = Imaginary))
p <- p +
  geom_point(shape = I(3)) +
  theme(legend.position = "none")

# now add the vertical and horizontal line
p <- p + geom_hline(aes(yintercept = 0))
p <- p + geom_vline(aes(xintercept = 0))

# finally, add the ellipse
p <- p + geom_polygon(data = ellDF, aes(x = Real, y = Imaginary, alpha = 1/20, fill = "red"))

# print plot to pdf
pdf("../Results/Girko.pdf")
p
dev.off()


**********************************************************************

Testing Girko.R...

Output (only first 500 characters): 

**********************************************************************
null device 
          1 

**********************************************************************

Code ran without errors

Time consumed = 1.40935s

======================================================================
Inspecting script file Vectorize1.R...

File contents are:
**********************************************************************
############## Speed of loops vs in-built functions ###############

# Contains two methods for calculating the sum of a matrix. 
# The first is a function, SumAllElements, containing a for loop and the second 
# is the inbuilt 'sum' function. The prints show which method is faster.

# Author: Lucy Goodyear (lucy.goodyear19@imperial.ac.uk)
# Version: 0.0.1

# clear workspace
rm(list=ls())

# create 1000 by 1000 matrix with random uniform numbers
M <- matrix(runif(1000000), 1000, 1000)

# calculate sum of matrix using for loop
SumAllElements <- function(M){
    Dimensions <- dim(M)
    Tot <- 0
    for (i in 1: Dimensions[1]){
        for (j in 1:Dimensions[2]){
            Tot <- Tot + M[i, j]
        }
    }
    return (Tot)
}

# call the SumAllElements function on matrix M and time it
print(paste("Using loops, the time taken is:", system.time(SumAllElements(M))[3]))

# sum all elements of matrix M using the in-built function "sum" and time it
print(paste("Using the in-built vectorized function, the time taken is:", system.time(sum(M))[3]))
            
            **********************************************************************

Testing Vectorize1.R...

Output (only first 500 characters): 

**********************************************************************
[1] "Using loops, the time taken is: 0.087"
[1] "Using the in-built vectorized function, the time taken is: 0.001"

**********************************************************************

Code ran without errors

Time consumed = 0.26014s

======================================================================
Inspecting script file break.R...

File contents are:
**********************************************************************
############## Practice using break command ####################

# uses break command to break out of a simple loop. 

# Author: Lucy Goodyear (lucy.goodyear19@imperial.ac.uk)
# Version: 0.0.1

# clear workspace
rm(list=ls())

# while loop that prints the numbers i equals 1-9 
# (breaks out of loop when i is 10)
i <- 0 # initialise i
while (i < Inf) {
    if (i == 10) {
        break
    } # break out of while loop
    else {
        cat("i equals ", i, "\n")
        i <- i + 1 # update i
    }
}
**********************************************************************

Testing break.R...

Output (only first 500 characters): 

**********************************************************************
i equals  0 
i equals  1 
i equals  2 
i equals  3 
i equals  4 
i equals  5 
i equals  6 
i equals  7 
i equals  8 
i equals  9 

**********************************************************************

Code ran without errors

Time consumed = 0.12375s

======================================================================
Inspecting script file basic_io.R...

File contents are:
**********************************************************************
############## R input-output ####################

# illustrates R input-output: loads data from a csv, 
# writes data to a csv and then makes changes to that csv

# Author: Lucy Goodyear (lucy.goodyear19@imperial.ac.uk)
# Version: 0.0.1

# clear workspace
rm(list=ls())

# A simple script to illustrate R input-output.
# Run line by line and check inputs outputs to understand what is happening.

MyData <- read.csv("../Data/trees.csv", header = TRUE) # import with headers

write.csv(MyData, "../Results/MyData.csv") # write it out as a new file

write.table(MyData[1,], file = "../Results/MyData.csv", append = TRUE) # append to it

write.csv(MyData, "../Results/MyData.csv", row.names = TRUE) # write row names

write.table(MyData, "../Results/MyData.csv", col.names = FALSE) # ignore column names**********************************************************************

Testing basic_io.R...

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error (or warning):
Warning message:
In write.table(MyData[1, ], file = "../Results/MyData.csv", append = TRUE) :
  appending column names to file

======================================================================
Inspecting script file Vectorize1.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

"""
Contains two methods for calculating the sum of a matrix. 
The first is a function, SumAllElements, containing a for loop and the second 
is the inbuilt 'sum' function. The prints show which method is faster.
"""

__author__ = 'Lucy Goodyear (lucy.goodyear19@imperial.ac.uk)'
__version__ = '0.0.1'

# imports
import scipy as sc
import scipy.stats as scs
import time

# create 1000 by 1000 matrix with random uniform numbers
M = sc.random.normal(size = (1000, 1000))

# calculate sum of matrix using for loop
def SumAllElements(M):
    '''
    Sums all elements of a matrix using a 
    for loop

    Parameters:
        M (matrix) : any matrix

    Returns:
        Tot (float) : the sum of all elements in M
    '''

    Tot = 0
    for i in range(0, len(M[0])):
        for j in range(0, len(M[1])):
            Tot = Tot + M[i, j]
    return Tot

# call the SumAllElements function on matrix M and time it
start = time.time()
SumAllElements(M)
end = time.time()
print("Using loops, the time taken is:")
print(end - start)

# sum all elements of matrix M using the in-built scipy function "sum" and time it
start = time.time()
sc.sum(M)
end = time.time()
print("Using in-built scipy sum function, the time taken is:")
print(end - start)**********************************************************************

Testing Vectorize1.py...

Vectorize1.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Missing docstring, either in one or functions and/or at the script level

Current Points = 96.5

Output (only first 500 characters): 

**********************************************************************
Using loops, the time taken is:
0.18505597114562988
Using in-built scipy sum function, the time taken is:
0.0006284713745117188

**********************************************************************

Code ran without errors

Time consumed = 0.56181s

======================================================================
Inspecting script file try.R...

File contents are:
**********************************************************************
############ Practise catching errors and debugging ##############

# Author: Lucy Goodyear (lucy.goodyear19@imperial.ac.uk)
# Version: 0.0.1

# clear workspace
rm(list=ls())

# create a funtion with a custom made error
doit <- function(x){
    x_temp <- sample(x, replace = TRUE)
    if(length(unique(x_temp)) > 30) { # only take mean if sample was sufficient
        print(paste("mean of this sample was: ", as.character(mean(x_temp))))
    }
    else {
        stop("Couldn't calculate mean: too few unique values")
    }
}

popn <- rnorm(50) # generate your population

# this will stop the script with an error
#lapply(1:15, function(i) doit(popn))

result <- lapply(1:15, function(i) try(doit(popn), FALSE))

# this is the manual version of the above
#result <- vector("list", 15) # preallocate/initialise
#for(i in 1:15) {
#   result[[i]] <- try(doit(popn), FALSE)
#}
**********************************************************************

Testing try.R...

Output (only first 500 characters): 

**********************************************************************
[1] "mean of this sample was:  -0.00450017755068765"
[1] "mean of this sample was:  0.248740006689277"
[1] "mean of this sample was:  0.0346794227432178"
[1] "mean of this sample was:  0.080390570692356"
[1] "mean of this sample was:  0.138650562701005"
[1] "mean of this sample was:  0.0410042825014035"
[1] "mean of this sample was:  -0.0187002384612023"
[1] "mean of this sample was:  0.0376327308860258"
[1] "mean of this sample was:  0.0691539431632893"
[1] "mean of this sample was:  0.309432613
**********************************************************************

Encountered error (or warning):
Error in doit(popn) : Couldn't calculate mean: too few unique values
Error in doit(popn) : Couldn't calculate mean: too few unique values

======================================================================
Inspecting script file apply2.R...

File contents are:
**********************************************************************
######### Practice script looking at using apply on my own function #########

# Contains a function that takes one parameter, which, if the sum
# is greater than 0, is returned multipled by 100. The apply function 
# is used to apply this function to a matrix by row.

# Author: Lucy Goodyear (lucy.goodyear19@imperial.ac.uk)
# Version: 0.0.1

# clear workspace
rm(list=ls())

# create a function
SomeOperation <- function(v) {
    if (sum(v) > 0){
        return(v * 100)
    }
    return(v)
}

# create a test argument and use apply to run your function on
# all elements at once
M <- matrix(rnorm(100), 10, 10)
print (apply(M, 1, SomeOperation))
**********************************************************************

Testing apply2.R...

Output (only first 500 characters): 

**********************************************************************
            [,1]        [,2]       [,3]        [,4]       [,5]       [,6]
 [1,] -0.4461056  119.472312  -31.45929   37.269177  34.151010  0.4514150
 [2,]  0.3136358   98.160300 -102.41835  109.698034 174.429716  1.2258228
 [3,] -0.8186651   65.922337  149.33662  129.869185  39.982268 -0.8685572
 [4,]  1.4695382  184.844165   34.48889   57.605001 -97.122809 -1.4925913
 [5,] -0.1492560   -1.471693  -50.63208   11.314415  96.821343 -1.8335688
 [6,] -0.8382724  110.522581   56.22624  158.140686 -38.4
**********************************************************************

Code ran without errors

Time consumed = 0.12695s

======================================================================
Inspecting script file get_TreeHeight.R...

File contents are:
**********************************************************************
########### Calculate tree heights from a given csv of distances and angles ##########

# Contains a function, TreeHeight, that calculates heights of trees given the distance
# of each tree from its base and angle to its top, using the trigonometric formula. 
# This function is called on data from a csv file, which has been provided by the user 
# as a command line argument, the results of which are added as an additional column to 
# the dataframe. The new dataframe is saved as a csv, the name of which includes the 
# basename of the input csv.

# Author: Lucy Goodyear (lucy.goodyear19@imperial.ac.uk)
# Version: 0.0.1

# clear workspace
rm(list=ls())

# This function calculates heights of trees given the distance
# of each tree from its base and angle to its top, using the 
# trigonometric formula

# height = distance * tan(radians)

# Arguments:
# degrees: The angle of elevation of tree
# distance: The distance from base of tree (e.g. metres)

# Output:
# the heights of the trees, same units as "distance"

TreeHeight <- function(degrees, distance){
    radians <- degrees * pi / 180
    height <- distance * tan(radians)
    # commented out print function below to improve speed with large datasets
    #print(paste("Tree height is", height))

    return(height)
}

# read command line arguments
args <- commandArgs(trailingOnly=TRUE)

# if statement to check a data file has been provided as an argument
if (length(args) == 0) {
    stop("No input file detected: please provide a data file")
} else {
    # reads input csv
    Tree_data <- read.csv(paste0(args[1]))
    namebase <- args[1]
}

# add column to Tree_data to include tree heights, calculated by the TreeHeight function
Tree_data$Tree.Height.m <- TreeHeight(Tree_data$Angle.degrees, Tree_data$Distance.m)

# use in-built "tools" package to obtain only the filename (remove relative path and extension) 
name <- tools::file_path_sans_ext(basename(namebase))

# write data to csv using the input filename
write.csv(Tree_data, paste0("../Results/", name, "_treeheights_R.csv"))
**********************************************************************

Testing get_TreeHeight.R...

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error (or warning):
Error: No input file detected: please provide a data file
Execution halted

======================================================================
Inspecting script file TAutoCorr.R...

File contents are:
**********************************************************************
#############################################################################
##################### Autocorrelation in weather ############################
#############################################################################

# loads and plots a dataset of temperatures by year in Key West. It creates two 
# lists offset from each other by one year, which allows the correltaion to be 
# calculated for successive years. It then calculates the correlation coefficient 
# for 10,000 random permutations of the temperature in order to compare significance.

# Author: Lucy Goodyear (lucy.goodyear19@imperial.ac.uk)
# Version: 0.0.1

# clear workspace
rm(list=ls())
#dev.off()

# imports
library(dplyr)

# load weather data
load("../Data/KeyWestAnnualMeanTemperature.Rdata")

# plot tmperatures over time on line graph
pdf("../Results/KWAMT.pdf")
plot(ats$Year,
     ats$Temp, 
     xlab = "Temp (Degrees Centigrade)",
     ylab = "Year",
     type = "l")
dev.off()

# create two lists of tmperatures, one with the first row deleted and then
# realigned with the second list so temps between suuccesive years can be
# easily compared
Temp_t0 <- c(ats[2:100,2])
Temp_t1 <- c(ats[1:99,2])

# calculate the correlation between successive years
CorCoeff <- cor(Temp_t0, Temp_t1)
cat("Correlation between successive years is", CorCoeff)

# create matrix of 10000 random permututions of temperature column
Temps1 <- replicate(10000,  sample(ats$Temp,replace = F))

# for each permutation, realign as before and then calculate correlation
RdmCors <- vector("numeric", 10000)
for (i in 1 : 10000) {
        RdmTemps <- cor( Temps1[2:100,i], Temps1[1:99,i])
        RdmCors[i] <- RdmTemps
}

# generate histogram comparing p-values
pdf("../Results/KWAMT_corr.pdf")
hist(RdmCors, 
     xlim = c(-0.4, 0.4),
     xlab = "Correlation Coefficients",
     main = NULL)
abline(v = CorCoeff, col = "red", lwd = 1, lty = 2)
text(CorCoeff, 1950, "correlation coefficient for\n successive years")
dev.off()

# calculate out estimated p-value (the fraction of correlation coefficients more
# significant than that of successive years (CorCoeff))
p_estimate <- (sum(RdmCors > CorCoeff) + sum (RdmCors < -CorCoeff)) / 10000

# print p_estimate to screen
cat("P-value estimate is", p_estimate)


**********************************************************************

Testing TAutoCorr.R...

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error (or warning):

Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

Error in readChar(con, 5L, useBytes = TRUE) : cannot open the connection
Calls: load -> readChar
In addition: Warning message:
In readChar(con, 5L, useBytes = TRUE) :
  cannot open compressed file '../Data/KeyWestAnnualMeanTemperature.Rdata', probable reason 'No such file or directory'
Execution halted

======================================================================
Inspecting script file browser.R...

File contents are:
**********************************************************************
######### inserts a breakpoint into the code and enters browser mode #########

# Author: Lucy Goodyear (lucy.goodyear19@imperial.ac.uk)
# Version: 0.0.1

# clear workspace
rm(list=ls())

Exponential <- function(N0 = 1, r = 1, generations = 10) {
    # runs a simulation of exponential growth
    # returns a vector of length generations

    N <- rep(NA, generations) # creates a vector of NA

    N[1] <- N0
    for (t in 2:generations) {
        N[t] <- N[t-1] * exp(r)
        browser()
    }
    return(N)
}

# plots the exponential growth
plot(Exponential(), type="1", main="Exponential growth")
**********************************************************************

Testing browser.R...

Output (only first 500 characters): 

**********************************************************************
Called from: Exponential()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()

**********************************************************************

Encountered error (or warning):
Error in plot.xy(xy, type, ...) : invalid plot type '1'
Calls: plot -> plot.default -> plot.xy
Execution halted

======================================================================
Inspecting script file Vectorize2.R...

File contents are:
**********************************************************************
###################### Stochastic (with gaussian fluctuations)######################
################################### Ricker Eqn. ####################################

# Contains two functions that run two different simulations of the stochastic 
# (with Gaussian fluctuations) Ricker equation. One contains two for loops, stochrick,
# the other, stochrickvect, has been vectorised. The times taken for the two models 
# to run are compared at the end.

# Author: Lucy Goodyear (lucy.goodyear19@imperial.ac.uk)
# Version: 0.0.1

# clear workspace
rm(list=ls())

# define stochastic (with Gaussian fluctuations) Ricker equation with two for loops
stochrick<-function(p0=runif(1000,.5,1.5),r=1.2,K=1,sigma=0.2,numyears=100) {
    # Runs a simulation of the stochastic Ricker equation, looping over
    # each population and each year, adding the gaussian fluctuation to 
    # each population separately.
  
    # initialise matrix of zeros
    N<-matrix(NA,numyears,length(p0))
    # set initial population density
    N[1,]<-p0
  
    for (pop in 1:length(p0)) { #loop through the populations
      
        for (yr in 2:numyears) { #for each pop, loop through the years
          
            N[yr,pop]<-N[yr-1,pop]*exp(r*(1-N[yr-1,pop]/K)+rnorm(1,0,sigma))
        }
    }
 return(N)
}

# Now write another function called stochrickvect that vectorizes the above 
# to the extent possible, with improved performance: 

stochrickvect <- function(p0=runif(1000,.5,1.5),r=1.2,K=1,sigma=0.2,numyears=100) {
    # Runs a simulation of the stochastic Ricker equation, looping over
    # each year and adding the gaussian fluctuation to all populations at once
    # each year.
  
    # initialise matrix of zeros
    N<-matrix(NA,numyears,length(p0))
    # set initial population density
    N[1,]<-p0
  
    for (yr in 2:numyears) { # loops through populations by year
      
        N[yr,] <- N[yr-1,] * exp(r * (1 - N[yr-1,] / K) + rnorm(length(p0), 0, sigma))
    }
    return(N)
}

# compare times for calling the vectorised and non-vectorised functions
print(paste("Stochastic Ricker without vectorisation takes:", system.time(res1<-stochrick())[3]))

print(paste("Vectorized Stochastic Ricker takes:", system.time(res2<-stochrickvect())[3]))

**********************************************************************

Testing Vectorize2.R...

Output (only first 500 characters): 

**********************************************************************
[1] "Stochastic Ricker without vectorisation takes: 0.237"
[1] "Vectorized Stochastic Ricker takes: 0.018"

**********************************************************************

Code ran without errors

Time consumed = 0.37549s

======================================================================
Inspecting script file DataWrangTidy.R...

File contents are:
**********************************************************************
##################################################################
################## Wrangling the Pound Hill Dataset ##############
##################################################################

# Author: Lucy Goodyear (lucy.goodyear19@imperial.ac.uk)
# Version: 0.0.1

require(dplyr)
require(tidyr)

############# Load the dataset ###############
# header = false because the raw data don't have real headers
MyData <- as.matrix(read.csv("../Data/PoundHillData.csv",header = F)) 

# header = true because we do have metadata headers
MyMetaData <- read.csv("../Data/PoundHillMetaData.csv",
                       header = T, 
                       sep=";", 
                       stringsAsFactors = F)

############# Inspect the dataset ###############
head(MyData)
dim(MyData)
glimpse(MyData) # in dplyr package, like str() but tidier
#fix(MyData) #you can also do this
#fix(MyMetaData)

######################## Transpose #######################
# To get those species into columns and treatments into rows 
MyData <- t(MyData) 
head(MyData)
dim(MyData)

############# Replace species absences with zeros ###############
MyData[MyData == ""] = 0

############# Convert raw matrix to data frame ###############

TempData <- as.data.frame(MyData[-1,],stringsAsFactors = F) #stringsAsFactors = F is important!
colnames(TempData) <- MyData[1,] # assign column names from original data

############# Convert from wide to long format  ###############

# using dplyr
MyWrangledData <- TempData %>% 
                  gather(Species, Count, -Cultivation, -Block, -Plot, -Quadrat)

# set the location columns as factors and set count as numeric
MyWrangledData <- MyWrangledData %>%
                  mutate(Cultivation = factor(Cultivation),
                         Block = factor(Block),
                         Plot = factor(Plot),
                         Quadrat = factor(Quadrat),
                         Count = as.integer(Count))

glimpse(MyWrangledData) # like str() but tidier
head(MyWrangledData)
dim(MyWrangledData)

############# Exploring the data (extend the script below)  ###############

**********************************************************************

Testing DataWrangTidy.R...

Output (only first 500 characters): 

**********************************************************************
     V1                     V2        V3        V4        V5        V6       
[1,] "Cultivation"          "october" "october" "october" "october" "october"
[2,] "Block"                "a"       "a"       "a"       "a"       "a"      
[3,] "Plot"                 "1"       "1"       "1"       "1"       "1"      
[4,] "Quadrat"              "Q1"      "Q2"      "Q3"      "Q4"      "Q5"     
[5,] "Achillea millefolium" "4"       "8"       "3"       "20"      "6"      
[6,] "Agrostis gigantea"    ""   
**********************************************************************

Encountered error (or warning):
Loading required package: dplyr

Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

Loading required package: tidyr

======================================================================
Inspecting script file preallocate.R...

File contents are:
**********************************************************************
############### Two methods of creating a matrix ################

# Two methods of creating a matrix, one without using preallocation 
# (function, f) and one using preallocaiton (function, g). The 
# times taken for each function to run are printed to allow comparison.

# Author: Lucy Goodyear (lucy.goodyear19@imperial.ac.uk)
# Version: 0.0.1

# clear workspace
rm(list=ls())

# initialise empty variable
a <- NA

# function to add the numbers 1 to 10000 to a using a for loop
f <- function(a) {
    for (i in 1:10000) {
        a <- c(a, i)
        
        # in-function print commands have been commented out 
        # to increase speed
        
        #print(a)
        #print(object.size(a))
    }
}

# initialise and preallocate empty matrix
a <- rep(NA, 10)

# function to insert the numbers 1 to 10000 into preallocated matrix
g <- function(a) {
    for (i in 1:10000) {
        a[i] <- i
        
        # in-function print commands have been commented out 
        # to increase speed
        
        #print(a)
        #print(object.size(a))
    }
}

# compare difference in computing times:

# time taken for first function
print("Time taken without preallocation:")
print(system.time(f(a)))

# time taken for second function
print("Time taken with preallocation:")
print(system.time(g(a)))**********************************************************************

Testing preallocate.R...

Output (only first 500 characters): 

**********************************************************************
[1] "Time taken without preallocation:"
   user  system elapsed 
  0.160   0.020   0.158 
[1] "Time taken with preallocation:"
   user  system elapsed 
  0.004   0.000   0.005 

**********************************************************************

Code ran without errors

Time consumed = 0.28138s

======================================================================
Inspecting script file PP_Regress_loc.R...

File contents are:
**********************************************************************
################### Calculating a linear model for predator and prey masses ##########################
####################### by feeding type, predator lifestage and location #############################

# Calculates linear regression model for predator and prey masses separated by type of 
# feeding interaction, predator lifestage, location and then saves as csv demlimited table.

# Author: Lucy Goodyear (lucy.goodyear19@imperial.ac.uk)
# Version: 0.0.1

# clear workspace
rm(list=ls())

# imports
library(dplyr)

# load the data
MyDF <- read.csv("../Data/EcolArchives-E089-51-D1.csv")
dim(MyDF) # check the size of the data frame you loaded

# convert masses in mg to g
for (i in 1:nrow(MyDF)){
  if (MyDF$Prey.mass.unit[i] == "mg"){
    MyDF$Prey.mass.unit[i] = "g"
    MyDF$Prey.mass[i] = MyDF$Prey.mass[i] / 1000
  }
}

# calculate the regression models
LM <- MyDF %>% 
         # first remove subset that contains only 2 examples, both with same species of prey and predator, 
         # because f-statistic can't be calculated on this (and no linear regression line can be drawn)
         filter(Record.number != "30914" & Record.number != "30929") %>%
         # remove subset corresponding to filters below because all predator masses are the same so no linear
         # model can be fitted
         filter(Type.of.feeding.interaction != "predacious" | Predator.lifestage != "adult" | Location != "Gulf of Maine, New England") %>%
         # subset only the data needed and group by feeeding type, predator lifestage and location
         dplyr::select(Record.number, Predator.mass, Prey.mass, Predator.lifestage, Type.of.feeding.interaction, Location) %>%
         group_by(Type.of.feeding.interaction, Predator.lifestage, Location) %>%
         # do linear model calculations and store specific values as columns to dataframe
         do(mod=lm(Predator.mass ~ Prey.mass, data = .)) %>%
         mutate(Regression.slope = summary(mod)$coeff[2],
                Regression.intercept = summary(mod)$coeff[1],
                R.squared = summary(mod)$adj.r.squared,
                Fstatistic = summary(mod)$fstatistic[1],
                P.value = summary(mod)$coeff[8]) %>%
         dplyr::select(-mod) # remove column created by mod=lm command

# save the regression results to a csv delimited table
write.csv(LM, "../Results/PP_Regress_Loc_Results.csv")
**********************************************************************

Testing PP_Regress_loc.R...

Output (only first 500 characters): 

**********************************************************************
[1] 34931    15

**********************************************************************

Encountered error (or warning):

Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

Warning messages:
1: In summary.lm(mod) : essentially perfect fit: summary may be unreliable
2: In summary.lm(mod) : essentially perfect fit: summary may be unreliable
3: In summary.lm(mod) : essentially perfect fit: summary may be unreliable
4: In summary.lm(mod) : essentially perfect fit: summary may be unreliable
5: In summary.lm(mod) : essentially perfect fit: summary may be unreliable
6: In summary.lm(mod) : essentially perfect fit: summary may be unreliable
7: In summary.lm(mod) : essentially perfect fit: summary may be unreliable
8: In summary.lm(mod) : essentially perfect fit: summary may be unreliable
9: In summary.lm(mod) : essentially perfect fit: summary may be unreliable
10: In summary.lm(mod) : essentially perfect fit: summary may be unreliable

======================================================================
Inspecting script file DataWrang.R...

File contents are:
**********************************************************************
################################################################
################## Wrangling the Pound Hill Dataset ############
################################################################

# Author: Lucy Goodyear (lucy.goodyear19@imperial.ac.uk)
# Version: 0.0.1

############# Load the dataset ###############
# header = false because the raw data don't have real headers
MyData <- as.matrix(read.csv("../Data/PoundHillData.csv",header = F)) 

# header = true because we do have metadata headers
MyMetaData <- read.csv("../Data/PoundHillMetaData.csv",
                       header = T, 
                       sep=";", 
                       stringsAsFactors = F)

############# Inspect the dataset ###############
head(MyData)
dim(MyData)
str(MyData)
#fix(MyData) #you can also do this
#fix(MyMetaData)

############# Transpose ###############
# To get those species into columns and treatments into rows 
MyData <- t(MyData) 
head(MyData)
dim(MyData)

############# Replace species absences with zeros ###############
MyData[MyData == ""] = 0

############# Convert raw matrix to data frame ###############

TempData <- as.data.frame(MyData[-1,],stringsAsFactors = F) #stringsAsFactors = F is important!
colnames(TempData) <- MyData[1,] # assign column names from original data

############# Convert from wide to long format  ###############
require(reshape2) # load the reshape2 package

# ?melt #check out the melt function

MyWrangledData <- melt(TempData, 
                       id=c("Cultivation", "Block", "Plot", "Quadrat"), 
                       variable.name = "Species", 
                       value.name = "Count")

MyWrangledData[, "Cultivation"] <- as.factor(MyWrangledData[, "Cultivation"])
MyWrangledData[, "Block"] <- as.factor(MyWrangledData[, "Block"])
MyWrangledData[, "Plot"] <- as.factor(MyWrangledData[, "Plot"])
MyWrangledData[, "Quadrat"] <- as.factor(MyWrangledData[, "Quadrat"])
MyWrangledData[, "Count"] <- as.integer(MyWrangledData[, "Count"])

str(MyWrangledData)
head(MyWrangledData)
dim(MyWrangledData)

############# Exploring the data (extend the script below)  ###############

**********************************************************************

Testing DataWrang.R...

Output (only first 500 characters): 

**********************************************************************
     V1                     V2        V3        V4        V5        V6       
[1,] "Cultivation"          "october" "october" "october" "october" "october"
[2,] "Block"                "a"       "a"       "a"       "a"       "a"      
[3,] "Plot"                 "1"       "1"       "1"       "1"       "1"      
[4,] "Quadrat"              "Q1"      "Q2"      "Q3"      "Q4"      "Q5"     
[5,] "Achillea millefolium" "4"       "8"       "3"       "20"      "6"      
[6,] "Agrostis gigantea"    ""   
**********************************************************************

Encountered error (or warning):
Loading required package: reshape2

======================================================================
Inspecting script file MyBars.R...

File contents are:
**********************************************************************
##################### First plot with annotations #######################

# loads data from a .txt file and plots it as three line ranges
# (using ggplot2) with annotations for particular values.

# Author: Lucy Goodyear (lucy.goodyear19@imperial.ac.uk)
# Version: 0.0.1

# clear workspace
rm(list=ls())

# imports
library(ggplot2)

# read data
a <- read.table("../Data/Results.txt", header = TRUE)

# view data
head(a)

a$ymin <- rep(0, dim(a)[1]) # append a column of zeroes

# print the first linerange
p <- ggplot(a)
p <- p + geom_linerange(data = a, aes(
    x = x,
    ymin = ymin,
    ymax = y1,
    size = (0.5),
    colour = "#E69F00",
    alpha = 1/2),
    show.legend = TRUE)

# print the second linerange
p <- p + geom_linerange(data = a, aes(
    x = x,
    ymin = ymin,
    ymax = y2,
    size = (0.5),
    colour = "#56B4E9",
    alpha = 1/2),
    show.legend = FALSE)

# print the third linerange
p <- p + geom_linerange(data = a, aes(
    x =x,
    ymin = ymin,
    ymax = y3,
    size = (0.5),
    colour = "#D55E00",
    alpha = 1/2),
    show.legend = FALSE)

# annonate the plot with labels
p <- p + geom_text(data = a, aes(x =x, y = -500, label = Label))

# now set the axis labels, remove the legend, and preapre for bw printing
p <- p + scale_x_continuous("My x axis",
                            breaks = seq(3, 5, by = 0.05)) +
                            scale_y_continuous("My y axis") +
                            theme_bw() +
                            theme(legend.position = "none")

pdf("../Results/MyBars.pdf")
p #+ ggtitle("My first annotated plot")
dev.off()
**********************************************************************

Testing MyBars.R...

Output (only first 500 characters): 

**********************************************************************
         x   y1   y2 y3 Label
1 3.515424 4320 4320  0  <NA>
2 3.533984 2160 2160  0  <NA>
3 3.557647 4320 4320  0  <NA>
4 3.569953 4320 4320  0  <NA>
5 3.578984 8640 8640  0  <NA>
6 3.585665 2160 2160  0  <NA>
null device 
          1 

**********************************************************************

Encountered error (or warning):
Warning message:
Removed 91 rows containing missing values (geom_text). 

======================================================================
======================================================================
Finished running scripts

Ran into 14 errors

======================================================================
======================================================================

FINISHED WEEKLY ASSESSMENT

Current Points for the Week = 96.5

NOTE THAT THESE ARE POINTS, NOT MARKS FOR THE WEEK!